REQUIRE %vfxland5%/supershow/tilemap3.vfx
REQUIRE %vfxland5%/supershow/actor.vfx
REQUIRE %vfxland5%/supershow/stage.vfx
REQUIRE %vfxland5%/supershow/traits.vfx
REQUIRE %vfxland5%/supershow/autoload.vfx
REQUIRE %vfxland5%/cjson/cjson2.vfx

private

0 value tile#  0 value nextGID  0 value tsSrc  0 value jtilesets
0 value tmjSrc  0 value tsjSrc  0 value zname  0 value layerSrc
0 value tmjPath$

: jnamed? ( jobj zname - flag ) swap "name" j>z z$= ;

: gids, ( jlayer - )
    "data" j>j [: j@n , ;] jeach-fast ;

: *array-from-jlayer ( jlayer - array )
    >r cell array{ r> gids, array} ;

: j>dims ( layerSrc - w h )
    dup "width" j>n swap "height" j>n ;

: j>pos ( jobj - x. y. )
    >r r@ "x" j>p r@ "width" j>p 2 / +
       r@ "y" j>p r> "height" j>p 2 / - ;

: @actor ( jobj - actor|0 )
    {: obj :}
    obj "type" ['] j>s catch if
        2drop
        ." No 'type' property found in JSON object, skipping..." cr
        0 exit
    then
    f" %%%s" sfind if
        execute make {   
            obj j>pos x 2!
            obj "name" j>s tag$ place
            en on
        me }
    else
        ( $ ) f" Class %$ not found, skipping..." type cr
        0
    then ;

: stage-allocator ( n - a ior )
    drop stage-slot 0 ;

: to-stage
    ['] stage-allocator allocator! ;

: fix-gids ( ofs array - )
    [: dup @ if udup +! else drop then ;] swap eacha drop ;

public

class: %jsonfile
    %asset derive
    is-a %autoload
    is-a %loadable
    prop json :addr

    : _load-json ( - )
        me @data parse-json json ! ;

    :: on-startup ( - )
        ." Loading JSON file " me .name cr
        _load-json ;

class;

private

: set-meta ( bits index - ) 
    metas-array @ swap nth dup @ rot or swap ! ;

0 value id 
: get-tsj-properties ( tsj tileset - )
    {
        #tiles @` cell` %array make metas-array !
        metas-array @ o.
        ( tsj ) "tiles" ?j>j [: 
            dup "id" j>n to id
            "properties" ?j>j [: 
                "solid" jnamed? if $0F id set-meta then
            ;] jeach-fast 
        ;] jeach-fast
        me load-metas-from 
    } ;

: ?tileset ( jtileset - )
    to tsSrc

    tsSrc "source" j>s '.' ending s" tsj" s= not abort" Only .TSJ tilesets are supported."
    tsSrc "source" j>s -path sfind nip ?exit  \ tileset is already loaded

    tsSrc "source" j>s``
    tmjPath$ count '\' <scan`` 
    f" JSONFILE %s\%s" .evaluate  \ load the .TSJ file
    lastbody >json @ to tsjSrc

    tsjSrc "image" ['] j>s catch if 2drop exit then
    -path sfind nip 0= if
        tsjSrc "image" j>s``
        tmjPath$ count '\' <scan``
        f" BITMAP %s\%s" .evaluate  \ load the bitmap
    then

    tsSrc "source" j>s -path -ext``
    tsjSrc "tileheight" j>n`
    tsjSrc "tilewidth" j>n`
    tsjSrc "image" j>s -path``
    f" %s %n %n TILESET-FROM %s.ts" .evaluate
    tsjSrc lastbody get-tsj-properties
;

: find-first-nonzero ( array - n )
    0 [: ?dup if nip enough then ;] rot each ;

public

: jsonfile ( <path> - )
    bl parse 2dup -path %jsonfile asset { embed _load-json }
    does> dup >srcpath$ to tmjPath$ >json @ ;

: find-layer ( tmj zlayer-name - jlayer )
    to zname to tmjSrc
    0 tmjSrc "layers" j>j [: j>j dup zname jnamed? if nip else drop then ;] jeach
    ?dup 0= if -1 zname f" Layer '%z' not found" .abort then ;

: ?find-layer ( tmj zlayer-name - jlayer|0 )
    ['] find-layer catch if 2drop 0 then ;

: load-to-stage ( tmj zlayer-name - )
    {{ to-stage ?find-layer "objects" ?j>j [: j>j @actor drop ;] jeach }} ;

: load-tmj-tilesets ( tmj - )
    "tilesets" j>j [: j>j ?tileset ;] jeach ;

: find-tileset-ref ( tile# - jtileset|0 )
    to tile#
    tmjSrc load-tmj-tilesets
    tmjSrc "tilesets" j>j to jtilesets
    0
    jtilesets [:
        2dup j>j to tsSrc

        \ get nextGID
        1 + dup jtilesets jlen < if j>j "firstgid" j>n else 2drop 65536 then to nextGID

        \ if tile# within the range, get the tileset object
        tile#` tsSrc "firstgid" j>n` nextGID` within? if drop tsSrc enough then
    ;] jeach ;

: *tilemap-from ( tmj zlayername - tilemap )
    to zname to tmjSrc
    %tilemap dmake {
        tmjSrc load-tmj-tilesets
        tmjSrc zname find-layer to layerSrc
        layerSrc j>dims w 2!                           \ get dimensions
        layerSrc *array-from-jlayer ta !              \ get tiles (GID's)
        ta @ find-first-nonzero find-tileset-ref ( jtileset )
        ?dup if 
            dup 
            "source" j>s -ext f" %s.ts" evaluate ts !
            "firstgid" j>n negate  \ ts @ >baseid @ +
            ta @ fix-gids 
        then
    me } ;

: tilemap-from ( tileset tmj zname <name> - )
    create *tilemap-from drop ;

CLASS: %level
    IS-A %drawable
    PROP layers :ref %array
    PROP sprlayer#
    PROP bsprlayer# 
    template { 1 sprlayer# ! }

    :: draw ( - )
        0 
        [:  over bsprlayer# @ = if backsprites then
            over sprlayer# @ = if sprites then
            0 0 at draw  1 + 
        ;] layers @ each
        dup bsprlayer# @ = if backsprites then
        sprlayer# @ = if sprites then ;
CLASS;

: n*array ( ... n - array )
    cell array{ >r for , loop r> array} ;

: *LEVEL ( tmj <layernames> - level )
    \ layers need to be listed in reverse order (TODO: fix??)
    {: tmj | cnt zbuf[ 256 ] :}
    0 to cnt
    %level dmake { 
        begin bl parse dup while
            zbuf[ zplace 
            tmj zbuf[ *tilemap-from ( add to stack )
            1 +to cnt
        repeat 2drop
        cnt n*array layers !
    me } ;

: LEVEL ( tmj <name> <layernames> - )
    create *level drop ;