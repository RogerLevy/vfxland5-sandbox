REQUIRE %vfxland5%/supershow/tilemap3.vfx
REQUIRE %vfxland5%/supershow/actor.vfx
REQUIRE %vfxland5%/supershow/stage.vfx
REQUIRE %vfxland5%/supershow/traits.vfx
REQUIRE %vfxland5%/supershow/autoload.vfx
REQUIRE %vfxland5%/cjson/cjson.vfx

private

0 value tile#  0 value nextGID  0 value tsSrc  0 value jtilesets
0 value tmjSrc  0 value tsjSrc  0 value zname  0 value layerSrc
0 value tmjPath$

: gids, ( jlayer - )
    "data" j@ [: j>int , ;] jeach-fast ;

: *array-from-jlayer ( jlayer - array )
    >r cell array{ r> gids, array} ;

: @dims ( layerSrc - w h )
    dup "width" j@n swap "height" j@n ;

: j@pos ( jobj - x. y. )
    >r r@ "x" j@p r@ "width" j@p 2 / +
       r@ "y" j@p r> "height" j@p 2 / - ;

: @actor ( jobj - actor|0 )
    {: obj :}
    obj "type" ['] j@s catch if
        2drop
        ." No 'type' property found in JSON object, skipping..." cr
        0 exit
    then
    f" %%%s" sfind if
        execute make {   
            obj j@pos x 2!
            obj "name" j@s tag$ place
            en on
        me }
    else
        ( $ ) f" Class %$ not found, skipping..." type cr
        0
    then ;

: stage-allocator ( n - a ior )
    drop stage-slot 0 ;

: to-stage
    ['] stage-allocator allocator! ;

: fix-gids ( ofs array - )
    [: dup @ if udup +! else drop then ;] swap eacha drop ;

public

class: %jsonfile
    %asset derive
    is-a %autoload
    is-a %loadable
    prop json :addr

    : _load-json ( - )
        me @data parse-json json ! ;

    :: on-startup ( - )
        ." Loading JSON file " me .name cr
        _load-json ;

class;

: jsonfile ( <path> - )
    bl parse 2dup -path %jsonfile asset { embed _load-json }
    does> dup >srcpath$ to tmjPath$ >json @ ;

: jnamed? ( jobj zname - flag ) swap "name" j@z z$= ;

: find-layer ( tmj zlayer-name - jlayer )
    to zname to tmjSrc
    0 tmjSrc "layers" j@ [: j@ dup zname jnamed? if nip else drop then ;] jeach
    ?dup 0= if -1 zname f" Layer '%z' not found" .abort then ;

: load-to-stage ( tmj zlayer-name - )
    {{ to-stage find-layer "objects" j@ [: j@ @actor drop ;] jeach }} ;

: ?tileset ( jtileset - )
    to tsSrc

    tsSrc "source" j@s '.' ending s" tsx" s= abort" Only .TSJ tilesets are supported."
    tsSrc "source" j@s -path sfind nip ?exit  \ tileset is already loaded

    tsSrc "source" j@s 
    tmjPath$ count '\' <scan
    f" jsonfile %s\%s" .evaluate  \ load the .TSJ file
    lastbody >json @ to tsjSrc

    tsjSrc "image" ['] j@s catch if 2drop exit then
    -path sfind nip 0= if
        tsjSrc "image" j@s 
        tmjPath$ count '\' <scan
        f" bitmap %s\%s" .evaluate  \ load the bitmap
    then

    tsSrc "source" j@s -path -ext
    tsjSrc "tileheight" j@n
    tsjSrc "tilewidth" j@n
    tsjSrc "image" j@s -path
    f" %s %n %n tileset-from %s.ts" .evaluate
;

: load-tmj-tilesets ( tmj - )
    "tilesets" j@ [: j@ ?tileset ;] jeach ;

: find-first-nonzero ( array - n )
    0 [: ?dup if nip enough then ;] rot each ;

: find-tileset-ref ( tile# - jtileset|0 )
    to tile#
    tmjSrc load-tmj-tilesets
    tmjSrc "tilesets" j@ to jtilesets
    0
    jtilesets [:
        2dup j@ to tsSrc

        \ get nextGID
        1 + dup jtilesets jlen < if j@ "firstgid" j@n else 2drop 65536 then to nextGID

        \ if tile# within the range, get the tileset object
        tile#` tsSrc "firstgid" j@n` nextGID` within? if drop tsSrc enough then
    ;] jeach ;

: *tilemap-from ( tmj zlayername - tilemap )
    to zname to tmjSrc
    %tilemap dmake {
        tmjSrc load-tmj-tilesets
        tmjSrc zname find-layer to layerSrc
        layerSrc @dims w 2!                           \ get dimensions
        layerSrc *array-from-jlayer ta !              \ get tiles (GID's)
        ta @ find-first-nonzero find-tileset-ref ( jtileset )
        ?dup if 
            dup 
            "source" j@s -ext f" %s.ts" evaluate ts !
            "firstgid" j@n negate  \ ts @ >baseid @ +
            ta @ fix-gids 
        then
    me } ;

: tilemap-from ( tileset tmj zname <name> - )
    create *tilemap-from drop ;

\ : get-metadata ( tsj - )
\     ;

CLASS: %level
    IS-A %drawable
    PROP layers :ref %array
    PROP sprlayer#
    PROP bsprlayer# 
    template { 1 sprlayer# ! }

    :: draw ( - )
        0 
        [:  over bsprlayer# @ = if backsprites then
            over sprlayer# @ = if sprites then
            0 0 at draw  1 + 
        ;] layers @ each
        dup bsprlayer# @ = if backsprites then
        sprlayer# @ = if sprites then ;
CLASS;

: *narray ( ... n - array )
    cell array{ >r for , loop r> array} ;

: LEVEL  ( tmj <name> <layernames>- )
    \ layers need to be listed in reverse order (TODO: fix??)
    {: tmj | cnt zbuf[ 256 ] :}
    0 to cnt
    create %level dmake { 
        begin bl parse dup while
            zbuf[ zplace 
            tmj zbuf[ *tilemap-from ( add to stack )
            1 +to cnt
        repeat ." done" cr 2drop
        cnt *narray layers !
    } ;
