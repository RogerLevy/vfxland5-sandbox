REQUIRE %vfxland5%/supershow/tilemap3.vfx
REQUIRE %vfxland5%/supershow/actor.vfx
REQUIRE %vfxland5%/supershow/stage.vfx
REQUIRE %vfxland5%/supershow/traits.vfx
REQUIRE %vfxland5%/supershow/autoload.vfx
REQUIRE %vfxland5%/cjson/cjson2.vfx

private

0 value tile#  0 value nextGID  0 value tsSrc  0 value jtilesets
0 value tmjSrc  0 value tsjSrc  create zname 32 allot  0 value layerSrc
0 value tmjPath$

: jnamed? ( jobj zname - flag ) swap "name" j>z z$= ;

: gids, ( jlayer - )
    "data" j>j [: j@u , ;] jeach-fast ;

: *array-from-jlayer ( jlayer - array )
    >r %int array{ r> gids, array} ;

: j>dims ( layerSrc - w h )
    dup "width" j>n swap "height" j>n ;

: j>pos ( jobj - x. y. )
    >r r@ "x" j>p r@ "width" j>p 2 / +
       r@ "y" j>p r> "height" j>p 2 / - ;

: @actor ( jobj - actor|0 )
    {: obj :}
    obj "type" ['] j>s catch if
        2drop
        ." No 'type' property found in JSON object, skipping..." cr
        0 exit
    then
    f" %%%s" sfind if
        execute make {   
            obj j>pos x 2!
            obj "name" j>s tag$ place
            en on
        me }
    else
        ( $ ) f" Class %$ not found, skipping..." type cr
        0
    then ;

: node-allocated ( n - a ior )
    [: drop frees pop 0 ;] allocator! ;

: fix-gids ( ofs array - )
    [: dup if udup + then ;] swap !each drop ;

public

class: %jsonfile
    %asset derive
    is-a %autoload
    is-a %loadable
    prop json :addr

    : _load-json ( - )
        me @data parse-json json ! ;

    :: on-startup ( - )
        ." Loading JSON file " me .name cr
        _load-json ;

class;

private

: set-meta ( bits index - ) 
    metas-array @ ['] or !el  ;

|| 0 value id 
: get-tsj-properties ( tsj tileset - )
    {
        #tiles @ %int %array make metas-array !
        ( tsj ) "tiles" ?j>j [: 
            dup "id" j>n to id
            "properties" ?j>j [: 
                "solid" jnamed? if $0F id set-meta then
            ;] jeach-fast 
        ;] jeach-fast
        me load-metas-from 
    } ;

: ?tileset ( jtileset - )
    to tsSrc

    tsSrc "source" j>s '.' ending s" tsj" s= not abort" Only .TSJ tilesets are supported."
    tsSrc "source" j>s -path sfind nip ?exit  \ tileset is already loaded

    tsSrc "source" j>s``
    tmjPath$ count '\' <scan`` 
    f" JSONFILE %s\%s" .evaluate  \ load the .TSJ file
    lastbody >json @ to tsjSrc

    tsjSrc "image" ?j>z -exit
    tsjSrc "image" j>s -path sfind nip 0= if
        tsjSrc "image" j>s``
        tmjPath$ count '\' <scan``
        f" BITMAP %s\%s" .evaluate  \ load the bitmap
    then

    tsSrc "source" j>s -path -ext``
    tsjSrc "tileheight" j>n`
    tsjSrc "tilewidth" j>n`
    tsjSrc "image" j>s -path``
    f" %s %n %n TILESET-FROM %s.ts" .evaluate
    tsjSrc lastbody get-tsj-properties
;

: find-first-nonzero ( array - n )
    0 [: ?dup if nip enough then ;] rot each ;

public

: JSONFILE ( <path> - ) ( - cjson )
    bl parse 2dup -path %jsonfile ASSET { embed _load-json }
    does> dup >srcpath$ to tmjPath$ >json @ ;

: find-layer ( tmj zlayer-name - jlayer )
    \ {: tmjSrc zname :}
    zname zmove   to tmjsrc
    0 tmjSrc "layers" j>j [: j>j dup zname jnamed? if nip else drop then ;] jeach
    ?dup 0= if -1 zname f" Layer '%z' not found" .abort then ;

: ?find-layer ( tmj zlayer-name - jlayer|0 )
    ['] find-layer catch if 2drop 0 then ;

: load-to-stage ( tmj zlayer-name - )
    {{ node-allocated ?find-layer "objects" ?j>j [: @actor stg@ push ;] jeach-fast }} ;

: load-tmj-tilesets ( tmj - )
    "tilesets" j>j [: j>j ?tileset ;] jeach ;

: find-tileset-ref ( tile# - jtileset|0 )
    to tile#
    tmjSrc load-tmj-tilesets
    tmjSrc "tilesets" j>j to jtilesets
    0
    jtilesets [:
        2dup j>j to tsSrc

        \ get nextGID
        1 + dup jtilesets jlen < if j>j "firstgid" j>n else 2drop 65536 then to nextGID

        \ if tile# within the range, get the tileset object
        tile#` tsSrc "firstgid" j>n` nextGID` within? if drop tsSrc enough then
    ;] jeach ;

: *tilemap-from ( tmj zlayername - tilemap )
    zname zmove  to tmjSrc
    %tilemap dmake {
        tmjSrc load-tmj-tilesets
        tmjSrc zname find-layer to layerSrc
        layerSrc j>dims w 2!                           \ get dimensions
        layerSrc *array-from-jlayer ta !              \ get tiles (GID's)
        ta @ find-first-nonzero find-tileset-ref ( jtileset )
        ?dup if 
            dup 
            "source" j>s -ext f" %s.ts" evaluate ts !
            "firstgid" j>n negate ta @ fix-gids 
        then
    me } ;

: TILEMAP-FROM ( tileset tmj zname <name> - )
    create *tilemap-from drop ;

ec-cell scn  \ current scene 

CLASS: %scene
    IS-A %drawable
    IS-A %loadable
    PROP layers :ref %iterable \ Array of tilemaps
    PROP sprlayer#
    PROP bsprlayer# 
    PROP on-load-xt :xt
    PROP srcdata :addr  \ Tiled cjson
    EC_MAX_SIZE NPROP ec  template { ec clear-ec }
    
    template { -1 bsprlayer# ! 999 sprlayer# ! }

    : layer ( scene - tilemap )
        scn@ >layers @ el@ ;

    :: draw ( - )
        0 
        [:  over bsprlayer# @ 1 + = if backsprites then
            over sprlayer# @ 1 + = if sprites then
            0 0 at draw  1 + 
        ;] layers @ each
        dup bsprlayer# @ 1 + <= if backsprites then
        sprlayer# @ 1 + <= if sprites then ;

    :: load ( - )
        me global { scn! }   \ set global scene
        just srcdata @ "objects" load-to-stage 
        on-load-xt @ ?oexec ;

CLASS;

0 %scene :construct ( - )
    8 %addr %stack make layers ! 
    ec ecp!  me scn!  ;

0 %actor :construct ( - )
    actor:construct
    you { map@ pile@ } pile! map!   \ hard-inherit pile and map
;

: *scene ( jsonfile <layernames> - scene )
    \ jsonfile must be in .TMJ format
    %scene dmake { 
        srcdata !
        begin bl parse dup while >zpad 
            srcdata @ swap *tilemap-from layers @ push
        repeat 2drop 
        layers @ #items if 
            \ Set default map and pile for scene
            0 layer map!
            0 layer >ts @ 0 tile pile!
        then
    me } ;

: scene ( tmj <name> <layernames> - )
    create *scene drop ;

