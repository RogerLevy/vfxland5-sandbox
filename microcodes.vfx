\ ==============================================================================
\ Micro-codes
\ ==============================================================================

((
experiments into the idea of tiny modular bits of logic
(combining "Forth encourages you to not just slice, but dice" with explorative game development)

what's the idea?

tiny little workers (invisible in release mode) perform just one simple action continuously
  and networks of them manipulate each other to accomplish more advanced logic

it's basically a Godot-like node system, just a million times simpler
and also it will be much more tangible and intuitive

it's part of my "physicality" project
    - program games tangibly
    - minimal UI
    - workspace system
    - code is data


))

\ -- Dependencies --------------------------------------------------------------

REQUIRE %vfxland5%/forge/lib/dltree.vfx
REQUIRE %vfxland5%/supershow/traits.vfx
REQUIRE %vfxland5%/supershow/bitmap.vfx
REQUIRE %vfxland5%/supershow/sprites.vfx
REQUIRE %vfxland5%/supershow/tileset.vfx
REQUIRE %vfxland5%/supershow/autoload.vfx
REQUIRE %idir%/shapes.vfx
REQUIRE %idir%/arrow.vfx
REQUIRE %idir%/colors.vfx
REQUIRE %idir%/gui.vfx

\ -- Assets -------------------------------------------------------------------

BITMAP micro-icons.png
micro-icons.png 20 20 TILESET-FROM micro-icons.ts

8.5 constant ICON_RADIUS

\ -- Traits -------------------------------------------------------------------

trait: %_micro
    :: _act    ( - ) ;
    :: _gather ( - ) ;
    :: act     ( - ) ;
    :: gather  ( - ) ;
    :: trigger ( - ) ;
    :: _hint    ( - a len ) s" " ;
    prop en          \ user disable switch
    prop val :fixed  \ coefficient, must be >= 0.01 to process
    prop dcy :fixed  \ scalar
    prop upul :fixed  
    \ prop dpul :fixed
    \ prop lpul :fixed
    prop rpul :fixed
    static icon-color \ rgba8
    static icon-bmp 
trait;

\ TODO: Propagate IS-A and WORKS-WITH with classifier dependents
class: %element  works-with %_micro  class;
class: %panel  works-with %_micro  class;
class: %label  works-with %_micro  class;

: pulse-up    1.0 upul ! ;
\ : pulse-down  1.0 dpul ! ;
\ : pulse-left   1.0 lpul ! ;
: pulse-right  1.0 rpul ! ;

trait: %animator
    prop anm 
    prop a.ts  prop a.spd  prop a.len
    prop a.ofs prop a.done prop a.flp
trait;

\ -- Base Class ---------------------------------------------------------------

ECONTEXT micro-ec

class: %micro
    128 field-space  \ enables in-place class changes
    %element derive
    is-a %_micro
    template { micro-ec ecp! in-heap en on 1.0 val ! 0.97 dcy ! -1 icon-color ! }
class;

\ -- Processing ---------------------------------------------------------------

%micro :: gather
    en @ -exit
    ['] gather me each 
    val @ 0.01 >= if 
        me _gather 
    then ;

%micro :: act 
    en @ -exit
    val @ 0.01 >= if
        me _act
    then
    ['] act me each ;

|| 0.025 constant ps

: pulse- ( val. - val'. ) 
    dup 0> if ps - 0 max else ps + 0 min then ;

defer _decay
: decay ( micro - )
    as> 
        me %micro is? -exit
        en @ -exit
        val @ 0.01 >= if val @ dcy @ p* val ! then
        upul @ pulse- upul !
        \ dpul @ pulse- dpul !
        \ lpul @ pulse- lpul !
        rpul @ pulse- rpul !
        ['] _decay me each ;
['] decay is _decay

: non-decaying  template { 1.0 dcy ! } ;

0 %micro :construct ( - )
    element:construct  micro-ec ecp! ;

\ -- Rendering ----------------------------------------------------------------

: val-alpha  $ffffff00 and  val @ 257.0 p/ or ;

: x-flow-color ( - )
\    $ff0000ff lpul @ mix 
    prev @ if $0000ffff prev @ >rpul @ mix then ;

: y-flow-color ( - )
    $ff0000ff upul @ mix ;
    \ parent @ if $80ffffff parent @ >dpul @ mix-rgba8 then ;

: changelen ( x1. y1. x2. y2. start. end. - x1'. y1'. x2'. y2'. )
    {: x1 y1 x2 y2 sc ec | ang :} 
    x1 y1 x2 y2 angle-to to ang
    x1 y1 ang 180.0 + sc vec 2+
    x2 y2 ang ec vec 2+ ;

: sibling-connector
    prev @ if
        $88ccff88 rgba8 x-flow-color
        prev @ { abspos } abspos ICON_RADIUS 0.5 + negate dup changelen
        2swap atp ->line
    then ;

: parent-connector
    parent @ if
        $ff888888 rgba8 y-flow-color
        abspos parent @ { abspos } ICON_RADIUS 0.5 + negate dup changelen
        2swap atp ->line
    then ;

: connectors
    e{ 1.0 thick sibling-connector parent-connector e} ;

: pulse@  upul @ ( dpul @ + ) ( lpul @ + ) rpul @ + 1.0 min ;

redef : icon
    pulse@ 0.01 > if
        icon-color @ rgba8   
        pulse@ ppena!
        9.5 circ     \ outer pulse circle
    then
    icon-color @ val-alpha rgba8 ICON_RADIUS circf  \ inner circle fill
    icon-color @ rgba8 ICON_RADIUS circ             \ inner circle rim
    icon-bmp @ cput ;

%micro :: .summary  
    object:.summary x 2p? ;

%micro :: _draw
    icon connectors ;

%micro :: click-box@
    abspos 8. 8. 2- 16. 16. box ;

\ -- Micro Classes -------------------------------------------------------------

c: %origin  %micro [non-decaying] ; 
c: %move    %micro ang acc ; \ val = speed
c: %ability %micro k kp kh kr [non-decaying] ; 
c: %rep     %micro dur t xt [non-decaying] ; \ val modulates speed
c: %timeout %micro dur t xt [non-decaying] ; \ val modulates speed
c: %hitbox  %micro w h lyr msk px py [non-decaying] ;
c: %neuron  %micro thr tst ;
c: %sprite  %micro %animator bmp [non-decaying] ; \ val modulates speed

\ -- Class Draw Methods --------------------------------------------------------

%origin :: _draw  
    icon ;

%sprite :: _draw
    bmp @ cput ;

%hitbox :: _draw
    icon
    white w 2@ rect 
    connectors ;

%rep :: _hint ( - a len )
    dur @ f" %p" ;

%timeout :: _hint ( - a len )
    dur @ f" %p" ;

%ability :: _hint ( - a len )
    k @ f" %n" ;

: hint ( element - )
    {: me | a len :} 
    me _hint to len to a
    len -exit
    me { at-me }
    5 5 +at 
    black 0.5 ppena! a len print 
    -1 -1 +at
    white 0.9 ppena! a len print ;

\ %ability :: _draw
\     icon
\     _ability-key
\     connectors ;

defer __hints
: hints ( element - ) 
    [: dup hint __hints ;] swap each ;
' hints is __hints

\ -- Class Templates -----------------------------------------------------------

%hitbox >template { 16.0 16.0 w 2! }
%neuron >template { 2.0 thr ! 0 val ! } 
%rep >template { 1.0 dur ! }
%timeout >template { 1.0 dur ! }
%move >template { 0 val ! }

\ -- Class Logic ------------------------------------------------------

%origin :: _process
    micro:gather   micro:act ;

\ stop processing gather/act at other origins.
%origin :: gather ;
%origin :: act ;

%move :: _act  
    acc @ val +!
    ang @ val @ vec parent @ >x 2+! 
    val @ 0.01 >= if pulse-up then ;

%ability :: _gather
    k @ pressed? if pulse-up kp @ parent @ { ?execute } then
    k @ held?    if pulse-up kh @ parent @ { ?execute } then
    k @ letgo?   if pulse-up kr @ parent @ { ?execute } then ;

%rep :: trigger
    pulse-up
    0 t !
    xt @ parent @ { ?execute } ;

%rep :: _gather 
    pdelta val @ p* t +! 
    t @ dur @ < ?exit
    me trigger ;

%timeout :: trigger
    pulse-up
    0 t ! 0 val !
    xt @ parent @ { ?execute } ;

%timeout :: _gather 
    pdelta val @ p* t +! 
    t @ dur @ < ?exit
    me trigger ;

%sprite :: _act 
    anm @ -exit
    val @ advance-animation bmp ! ;

: calc-vel ( element - vx. vy. )
    >x 2@ px 2@ 2- ;

\ %hitbox :: _act
\     parent @ calc-vel vx 2!
\     abspos w 2@ box hit-test 
\     parent @ >x 2@ px 2! ;
 
%neuron :: _gather
    tst @ ?execute
    val @ thr @ < ?exit
    parent @ if
        1.0 parent @ >val +!
        pulse-up
    then
    0 val ! ;

\ -- Lifecycle ----------------------------------------------------------------

0 0 at %desktop object machines

defer _delete-micro
: delete-micro ( micro - )
    >r 
    ['] _delete-micro r@ each
    r@ dlremove r> free throw ;
' delete-micro is _delete-micro

%micro :: delete  me delete-micro ;

\ -- Icon Configuration --------------------------------------------------------

|| : tile!  micro-icons.ts swap tile icon-bmp ! ;

%micro   >template { $00000080        icon-color !  0 icon-bmp ! }
%origin  >template { valof light-grey icon-color !  2  tile! }
%move    >template { valof cyan       icon-color !  0  tile! }
%ability >template { valof yellow     icon-color !  5  tile! }
%rep     >template { valof magenta    icon-color !  4  tile! }
%timeout >template { valof red        icon-color !  3  tile! }
%hitbox  >template { valof green      icon-color !  6  tile! }   
%neuron  >template { valof blue       icon-color !  1  tile! }

\ -- Main Loop ----------------------------------------------------------------

: process-micros
    machines process machines sweep ;

: draw-micros
    0 0 at 
    machines draw 
    machines hints
    ['] decay machines each ;
    
redef : process-input
    get-mouse machines gui-input ;

: micros
    microcodes>> machines as 
    work> process-input process-micros
    show> draw-micros gui-overlay ;

micros

\ -- DSL Syntax ---------------------------------------------------------------

\ || : level  parent @ dup if me swap indexof 1 + then ;
\ || : level ( - n )
\     {: | n :}
\     0 to n
\     prev @ begin ?dup while dup %origin is? not over #children 0> and if 1 +to n then >prev @ repeat 
\     n ;

machines value last-origin
: absy  abspos nip >i ;
0 value next-y

: {{ ( micro - )
    { e{
    me .summary ." absolute: " abspos 2p. cr
    me %origin is? if
        0 20 at
        me to last-origin
        absy 20 + to next-y
    else
        prev @ 0= if 20 +to next-y then   \ first child advances Y
        0 next-y absy - at          \ Y relative to current object
    then ;

: }}
    me %origin is? not >r
    e} }
    r> if 20 0 +at then ;

: *kpress ( key xt - ability )
    %ability add { kp ! k ! me } ;

\ -- Test ---------------------------------------------------------------------

c: %gravity %move [non-decaying] ;
%gravity >template { 90. ang ! 0.03 acc ! }

c: %rando %origin startx starty ;
0 %rando :construct micro:construct x 2@ startx 2! ;

: *rando
    %rando add {{
        0 20 at
        <del> [: me unload ;] *kpress {{ }}
        <enter> [: startx 2@ x 2! ;] *kpress {{ }}   \ couples this to a rando
        \ %gravity add { }
        %move add {{ 
            %rep add {{
                [: 1.0 val ! 360. rnd ang ! ;] xt !
                %ability add {{
                    <enter> k !
                    [: 0. val ! ;] kp !
                    [: 1. val ! me trigger ;] kr !
                }}
            }}
            %ability add {{
                <enter> k !
                [: 1. val ! ;] kh !
            }}
        }}
        %micro add {{
            %micro add {{ }}
        }}
    me }} ;

: test 
    machines {{
        64 64 at 
        \ *rando {{
            *rando {{ }}
        \ }}
        \ *rando {{
            \ *rando {{ }}
        \ }}
        \ *rando {{
        \     *rando {{ }}
        \ }}
        \ *rando {{
        \     *rando {{ }}
        \ }}
        32 200 at
        %origin add {{ 
            %move add {{ }}
            %ability add {{ }}
            %rep add {{ }}
            %timeout add {{ }}
            %neuron add {{ }}
            %hitbox add {{ }} \ -8. -8. x 2+!  16. 16. w 2! }}
        }}
    }}
;

test

10 10 at 
%panel make constant panel
panel machines unshift
panel {
    150. 100. w 2!
    10 10 at
    z" Hello, my baby!" *label constant label
}

