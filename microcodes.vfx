((
micro-codes

experiments into the idea of tiny modular bits of logic
(combining "Forth encourages you to not just slice, but dice" with explorative game development)

what's the idea?

tiny little workers (invisible in release mode) perform just one simple action continuously
  and networks of them manipulate each other to accomplish more advanced logic

it's basically a Godot-like node system, just a million times simpler
and also it will be much more tangible and intuitive

it's part of my "physicality" project
    - program games tangibly
    - minimal UI
    - workspace system
    - code is data


))

require %vfxland5%/forge/lib/dltree.vfx
require %vfxland5%/supershow/traits.vfx
require %vfxland5%/supershow/bitmap.vfx
require %vfxland5%/supershow/sprites.vfx

trait: %element
    is-a %dltree
    is-a %drawable
    prop x :fixed
    prop y :fixed
    :: clickbox@ ( - x1 y1 x2 y2 ) $DEADBEEF dup dup dup ;
trait;

: abspos  x 2@ begin >parent @ ?dup while { x 2@ 2+ me } repeat ;
: box  2over 2+ ;

trait: %micro-like
    :: action ;
trait;

trait: %animator
    prop anm 
    prop a.ts  prop a.spd  prop a.len
    prop a.ofs prop a.done prop a.flp
trait;

class: %micro
    96 field-space
    is-a %element
    is-a %micro-like
    prop en          \ user disable switch
    prop val :fixed  \ coefficient, must be >= 0.01 to process
    prop dcy :fixed  \ scalar
    template { 
        en on 
        1.0 val ! 
        0.97 dcy ! 
    }
class;

defer _process
: process ( micro - )
    as> en @ -exit
        val @ 0.01 < ?exit
        me action 
        ['] _process me each ;
['] process is _process

defer _decay
: decay ( micro - )
    as> en @ -exit
        val @ 0.01 < ?exit
        val @ dcy @ p* val !
        ['] _decay me each ;
['] decay is _decay


: non-decaying  template { 1.0 dcy ! } ;

c: %origin %micro [non-decaying] ; 
c: %move %micro ang acc ; \ val = speed
c: %ability %micro k kp kh kr [non-decaying] ; 
c: %rep %micro dur t xt [non-decaying] ; \ val modulates speed
c: %timeout %micro dur t xt [non-decaying] ; \ val modulates speed
c: %hitbox %micro w h lyr msk px py [non-decaying] ;
c: %neuron %micro thr ;
c: %sprite %micro %animator bmp [non-decaying] ; \ val modulates speed 

%origin :: clickbox@ abspos 16. 16. box ;

class: %panel
    is-a %element
    prop w :fixed 
    prop h :fixed
    :: clickbox@ abspos w 2@ box ;
class;

class: %inspector
    %panel derive
class;

\ : performs: >template { :noname action ! } ;
\ : perform  action ! ;

%move :: action  acc @ spd +!  ang @ spd @ vec parent @ >x 2+! ;

c: %gravity %move ;
\ %gravity >template { 0.01 ay ! }

%ability :: action 
    k @ pressed? if kp @ parent @ { ?execute } then
    k @ held? if kh @ parent @ { ?execute }  then
    k @ letgo? if kr @ parent @ { ?execute } then ;

%rep :: action 
    pdelta val @ p* t +! 
    dur @ t @ > ?exit
    0 t ! 
    xt @ parent @ { ?execute } 

%timeout :: action 
    pdelta val @ p* t +! 
    dur @ t @ > ?exit
    0 t ! 
    xt @ parent @ { ?execute }
    en off ;

%sprite :: draw  bmp @ cput ;

%sprite :: action 
    anm @ -exit
    val @ advance-animation bmp ! ;

: calc-vel ( element - vx. vy. )
    >x 2@ px 2@ 2- ;

\ %hitbox :: action
\     parent @ calc-vel vx 2!
\     abspos w 2@ box hit-test 
\     parent @ >x 2@ px 2! ;
 
%neuron :: action
    val @ thr @ >= dup next @ en ! ;

