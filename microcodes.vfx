\ ==============================================================================
\ Micro-codes
\ ==============================================================================

((
experiments into the idea of tiny modular bits of logic
(combining "Forth encourages you to not just slice, but dice" with explorative game development)

what's the idea?

tiny little workers (invisible in release mode) perform just one simple action continuously
  and networks of them manipulate each other to accomplish more advanced logic

it's basically a Godot-like node system, just a million times simpler
and also it will be much more tangible and intuitive

it's part of my "physicality" project
    - program games tangibly
    - minimal UI
    - workspace system
    - code is data


))

\ -- Dependencies --------------------------------------------------------------

REQUIRE %vfxland5%/forge/lib/dltree.vfx
REQUIRE %vfxland5%/supershow/traits.vfx
REQUIRE %vfxland5%/supershow/bitmap.vfx
REQUIRE %vfxland5%/supershow/sprites.vfx
REQUIRE %vfxland5%/supershow/tileset.vfx
REQUIRE %vfxland5%/supershow/autoload.vfx
REQUIRE %idir%/shapes.vfx
REQUIRE %idir%/arrow.vfx
REQUIRE %idir%/colors.vfx
REQUIRE %idir%/gui.vfx

\ -- Assets -------------------------------------------------------------------

\ allocator@ .name cr
BITMAP micro-icons.png
\ allocator@ .name cr
micro-icons.png 20 20 TILESET-FROM micro-icons.ts

8.5 constant ICON_RADIUS
24 constant ICON_SPACING

\ -- Traits -------------------------------------------------------------------

trait: %_micro
    :: _act    ( - ) ;
    :: _gather ( - ) ;
    :: act     ( - ) ;
    :: gather  ( - ) ;
    \ :: trigger ( - ) ;
    :: _hint    ( - a len ) s" " ;
trait;

\ TODO: Propagate IS-A and WORKS-WITH with classifier dependents
class: %element  works-with %_micro  class;
class: %panel  works-with %_micro  class;
class: %label  works-with %_micro  class;
class: %number  works-with %_micro  class;

trait: %animator
    prop anm 
    prop a.ts  prop a.spd  prop a.len
    prop a.ofs prop a.done prop a.flp
trait;

\ -- Base Class ---------------------------------------------------------------

ECONTEXT micro-ec

class: %micro
    %element derive
    128 field-space  \ enables in-place class changes
    prop en          \ user disable switch
    prop val :fixed  \ coefficient, must be >= 0.01 to process
    prop dcy :fixed  \ scalar
    prop upul :fixed  
    \ prop dpul :fixed
    \ prop lpul :fixed
    prop rpul :fixed
    prop org :ref %micro
    static icon-color \ rgba8
    static icon-bmp 
    is-a %_micro
    template { micro-ec ecp! in-heap en on 1.0 val ! 0.97 dcy ! -1 icon-color ! }
class;

\ -- Processing ---------------------------------------------------------------

: pulse-up    1.0 upul ! ;
\ : pulse-down  1.0 dpul ! ;
\ : pulse-left   1.0 lpul ! ;
: pulse-right  1.0 rpul ! ;

%micro :: gather
    en @ -exit
    ['] gather me each 
    val @ 0.01 >= if 
        me _gather 
    then ;

%micro :: act 
    en @ -exit
    val @ 0.01 >= if
        me _act
    then
    ['] act me each ;

|| 0.025 constant ps

: pulse- ( val. - val'. ) 
    dup 0> if ps - 0 max else ps + 0 min then ;

defer _decay
: decay ( micro - )
    as> 
        me %micro is? -exit
        en @ -exit
        val @ 0.01 >= if val @ dcy @ p* val ! then
        upul @ pulse- upul !
        \ dpul @ pulse- dpul !
        \ lpul @ pulse- lpul !
        rpul @ pulse- rpul !
        ['] _decay me each ;
['] decay is _decay

: non-decaying  template { 1.0 dcy ! } ;

0 %micro :construct ( - )
    element:construct  micro-ec ecp! ;

\ -- Rendering ----------------------------------------------------------------

: val-alpha  $ffffff00 and  val @ 257.0 p/ or ;

: x-flow-color ( - )
\    $ff0000ff lpul @ mix 
    prev @ if $0000ffff prev @ >rpul @ mix then ;

: y-flow-color ( - )
    $ff0000ff upul @ mix ;
    \ parent @ if $80ffffff parent @ >dpul @ mix-rgba8 then ;

: changelen ( x1. y1. x2. y2. start. end. - x1'. y1'. x2'. y2'. )
    {: x1 y1 x2 y2 sc ec | ang :} 
    x1 y1 x2 y2 angle-to to ang
    x1 y1 ang 180.0 + sc vec 2+
    x2 y2 ang ec vec 2+ ;

: sibling-connector
    prev @ if
        $88ccff88 rgba8 x-flow-color
        prev @ { abspos } abspos ICON_RADIUS 1.0 + negate dup changelen
        2swap atp ->line
    then ;

: parent-connector
    parent @ if
        $ff888888 rgba8 y-flow-color
        abspos parent @ { abspos } ICON_RADIUS 1.0 + negate dup changelen
        2swap atp ->line
    then ;

: connectors
    e{ 1.0 thick sibling-connector parent-connector e} ;

: pulse@  upul @ ( dpul @ + ) ( lpul @ + ) rpul @ + 1.0 min ;

redef : icon
    pulse@ 0.01 > if
        white
        pulse@ ppena!
        9.5 circ     \ outer pulse circle
    then
    icon-color @ val-alpha rgba8 ICON_RADIUS circf  \ inner circle fill
    icon-color @ rgba8 ICON_RADIUS circ             \ inner circle rim
    icon-bmp @ cput ;

%micro :: .summary  
    object:.summary x 2p? ;

%micro :: _draw
    icon connectors ;

%micro :: click-box@
    abspos 8. 8. 2- 16. 16. box ;

\ -- Micro Classes -------------------------------------------------------------

c: %origin  %micro [non-decaying] ; 
c: %move    %micro ang acc ; \ val = speed
c: %ability %micro k kp kh kr [non-decaying] ; 
c: %rep     %micro dur t xt [non-decaying] ; \ val modulates speed
c: %timeout %micro dur t xt [non-decaying] ; \ val modulates speed
c: %hitbox  %micro w h lyr msk px py [non-decaying] ;
c: %neuron  %micro thr tst ;
c: %sprite  %micro %animator bmp [non-decaying] ; \ val modulates speed

\ -- Class Draw Methods --------------------------------------------------------

%origin :: _draw  
    icon ;

%sprite :: _draw
    bmp @ cput ;

%hitbox :: _draw
    icon
    white w 2@ rect 
    connectors ;

%rep :: _hint ( - a len )
    dur @ f" %p" ;

%timeout :: _hint ( - a len )
    dur @ f" %p" ;

%ability :: _hint ( - a len )
    k @ f" %n" ;

: hint ( element - )
    {: me | a len :} 
    me _hint to len to a
    len -exit
    me { at-me }
    5 5 +at 
    black 0.5 ppena! a len print 
    -1 -1 +at
    white 0.9 ppena! a len print ;

\ %ability :: _draw
\     icon
\     _ability-key
\     connectors ;

defer __hints
: hints ( element - ) 
    [: dup hint __hints ;] swap each ;
' hints is __hints

\ -- Class Templates -----------------------------------------------------------

%hitbox >template { 16.0 16.0 w 2! }
%neuron >template { 2.0 thr ! 0 val ! } 
%rep >template { 1.0 dur ! }
%timeout >template { 1.0 dur ! }
%move >template { 0 val ! }

\ -- Class Logic ------------------------------------------------------

%origin :: _process
    micro:gather   micro:act ;

\ stop processing gather/act at other origins.
%origin :: gather ;
%origin :: act ;

%move :: _act  
    acc @ val +!
    ang @ val @ vec parent @ >x 2+! 
    val @ 0.01 >= if pulse-up then ;

%ability :: _gather
    k @ pressed? if kp @ ?dup if pulse-up parent @ { execute } then then
    k @ held?    if kh @ ?dup if pulse-up parent @ { execute } then then
    k @ letgo?   if kr @ ?dup if pulse-up parent @ { execute } then then ;

%rep :: _gather 
    pdelta val @ p* t +! 
    t @ dur @ < ?exit
    pulse-up
    0 t !
    xt @ parent @ { ?execute } ;

%timeout :: _gather 
    pdelta val @ p* t +! 
    t @ dur @ < ?exit
    pulse-up
    0 t ! 0 val !
    xt @ parent @ { ?execute } ;

%sprite :: _act 
    anm @ -exit
    val @ advance-animation bmp ! ;

: calc-vel ( element - vx. vy. )
    >x 2@ px 2@ 2- ;

\ %hitbox :: _act
\     parent @ calc-vel vx 2!
\     abspos w 2@ box hit-test 
\     parent @ >x 2@ px 2! ;
 
%neuron :: _gather
    tst @ ?execute
    val @ thr @ < ?exit
    parent @ if
        1.0 parent @ >val +!
        pulse-up
    then
    0 val ! ;

\ -- Lifecycle ----------------------------------------------------------------

0 0 at %desktop object machines
machines value last-origin

defer _delete-micro
: delete-micro ( micro - )
    >r 
    ['] _delete-micro r@ each
    r@ dlremove r> free throw ;
' delete-micro is _delete-micro

%micro :: delete  me delete-micro ;

\ -- Icon Configuration --------------------------------------------------------

|| : tile!  micro-icons.ts swap tile icon-bmp ! ;

%micro   >template { $00000080        icon-color !  0 icon-bmp ! }
%origin  >template { valof light-grey icon-color !  2  tile! }
%move    >template { valof cyan       icon-color !  0  tile! }
%ability >template { valof yellow     icon-color !  5  tile! }
%rep     >template { valof magenta    icon-color !  4  tile! }
%timeout >template { valof red        icon-color !  3  tile! }
%hitbox  >template { valof green      icon-color !  6  tile! }   
%neuron  >template { valof blue       icon-color !  1  tile! }

\ -- Main Loop ----------------------------------------------------------------

: process-micros
    machines process machines sweep ;

: draw-micros
    0 0 at 
    machines draw 
    machines hints ;
    
redef : process-input
    get-mouse machines gui-input ;

: track-origin 
    <space> held? lmb held? and ?exit
    selection #items if
        selection peek %origin is? if
            selection peek to last-origin
        then
        last-origin {  
            abspos machines { abspos } 2- 
            2negate 
            \ winw winh 2>p 0.5 0.5 2p*   zoom @ >p dup 2p/   2+
            64. 64. 2+
            \ 2dup 2p. cr
            machines >x 2!
        }
    then
;

|| 0 value dont-decay
: micros
    microcodes>> machines as 
    -1 to dont-decay
    work> 
        dont-decay not if
            ['] decay machines each 
            0 to dont-decay
        then
        process-input process-micros
    show> 
        \ track-origin 
        draw-micros 
        gui-overlay 
        0 0 at micro-icons.png put ;

micros

\ -- DSL Syntax ---------------------------------------------------------------

\ || : level  parent @ dup if me swap indexof 1 + then ;
\ || : level ( - n )
\     {: | n :}
\     0 to n
\     prev @ begin ?dup while dup %origin is? not over #children 0> and if 1 +to n then >prev @ repeat 
\     n ;

: absy  abspos nip >i ;
0 value next-y

: {{ ( micro - )
    { e{
    \ me .summary ." absolute: " abspos 2p. cr
    me %origin is? if
        0 ICON_SPACING at
        me to last-origin
        absy ICON_SPACING + to next-y
    else
        \ last-origin org !
        prev @ 0= if ICON_SPACING +to next-y then   \ first child advances Y
        0 next-y absy - at          \ Y relative to current object
    then ;

: }}
    me %origin is? not >r
    e} }
    r> if ICON_SPACING 0 +at then ;
