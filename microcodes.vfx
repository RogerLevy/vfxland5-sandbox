((
micro-codes

experiments into the idea of tiny modular bits of logic
(combining "Forth encourages you to not just slice, but dice" with explorative game development)

what's the idea?

tiny little workers (invisible in release mode) perform just one simple action continuously
  and networks of them manipulate each other to accomplish more advanced logic

it's basically a Godot-like node system, just a million times simpler
and also it will be much more tangible and intuitive

it's part of my "physicality" project
    - program games tangibly
    - minimal UI
    - workspace system
    - code is data


))

require %vfxland5%/forge/lib/dltree.vfx
require %vfxland5%/supershow/traits.vfx
require %vfxland5%/supershow/bitmap.vfx
require %vfxland5%/supershow/sprites.vfx
require %idir%/shapes.vfx

trait: %element
    is-a %dltree
    is-a %drawable
    prop x :fixed
    prop y :fixed
    :: clickbox@ ( - x1 y1 x2 y2 ) $DEADBEEF dup dup dup ;
trait;

: abspos  x 2@ me begin >parent @ ?dup while { x 2@ 2+ me } repeat ;
: box  2over 2+ ;

trait: %micro-like
    is-a %element
    :: action ;
    prop en          \ user disable switch
    prop val :fixed  \ coefficient, must be >= 0.01 to process
    prop dcy :fixed  \ scalar
    static icon-color \ rgba8
trait;

trait: %animator
    prop anm 
    prop a.ts  prop a.spd  prop a.len
    prop a.ofs prop a.done prop a.flp
trait;

class: %micro
    96 field-space
    is-a %micro-like
    template { en on 1.0 val ! 0.97 dcy ! -1 icon-color ! }
class;

defer _process
: process ( micro - )
    as> en @ -exit
        val @ 0.01 >= if 
            me action 
        then
        ['] _process me each ;
['] process is _process

defer _decay
: decay ( micro - )
    as> en @ -exit
        val @ 0.01 >= if
            val @ dcy @ p* val !
        then
        ['] _decay me each ;
['] decay is _decay

: non-decaying  template { 1.0 dcy ! } ;

0 %micro :construct ( - )
    at@p x 2!  16 0 +at ;

: val-alpha  $ffffff00 and  val @ 257.0 p/ or ;

%micro :: .summary  object:.summary x 2p? ;
%micro :: draw  
    abspos 2>i at 
    icon-color @ val-alpha rgba8 8. circf 
    icon-color @ rgba8 8. circ ;

c: %origin  %micro [non-decaying] ; 
c: %move    %micro ang acc ; \ val = speed
c: %ability %micro k kp kh kr [non-decaying] ; 
c: %rep     %micro dur t xt [non-decaying] ; \ val modulates speed
c: %timeout %micro dur t xt [non-decaying] ; \ val modulates speed
c: %hitbox  %micro w h lyr msk px py [non-decaying] ;
c: %neuron  %micro thr tst ;
c: %sprite  %micro %animator bmp [non-decaying] ; \ val modulates speed 

%origin :: clickbox@  abspos 16. 16. box ;
%hitbox :: draw  abspos 2>i at icon-color @ rgba8 w 2@ rect ;

%neuron >template { 2.0 thr ! 0.999 dcy ! } 
%rep >template { 0.5 dur ! }
%timeout >template { 1.0 dur ! }

\ class: %panel
\     is-a %element
\     prop w :fixed 
\     prop h :fixed
\     :: clickbox@ abspos w 2@ box ;
\ class;

\ class: %inspector
\     %panel derive
\ class;

\ : performs: >template { :noname action ! } ;
\ : perform  action ! ;

%move :: action  
    acc @ val +!
    ang @ val @ vec parent @ >x 2+! ;

c: %gravity %move [non-decaying] ;
%gravity >template { 90. ang ! 0.03 acc ! }

%ability :: action 
    k @ pressed? if kp @ parent @ { ?execute } then
    k @ held? if kh @ parent @ { ?execute }  then
    k @ letgo? if kr @ parent @ { ." KR " ?execute } then ;

%rep :: action 
    pdelta val @ p* t +! 
    t @ dur @ < ?exit
    0 t ! 
    xt @ parent @ { ?execute } ;

%timeout :: action 
    pdelta val @ p* t +! 
    t @ dur @ < ?exit
    0 t ! 
    xt @ parent @ { ?execute }
    en off ;

%sprite :: draw  
    at-me   bmp @ cput ;

%sprite :: action 
    anm @ -exit
    val @ advance-animation bmp ! ;

: calc-vel ( element - vx. vy. )
    >x 2@ px 2@ 2- ;

\ %hitbox :: action
\     parent @ calc-vel vx 2!
\     abspos w 2@ box hit-test 
\     parent @ >x 2@ px 2! ;
 
%neuron :: action
    tst @ ?execute
    val @ thr @ >= 
    next @ if dup next @ >val +! then
    if 0 val ! then ;

0 0 at %micro object machines
    machines { 1.0 dcy ! }


\ TODO: add >static syntax
$00ffffff %move -> icon-color !
$ffff00ff %ability -> icon-color !
$ff00ffff %rep -> icon-color !
$ff0000ff %timeout -> icon-color !
$00ff00ff %hitbox -> icon-color !
$0000ffff %neuron -> icon-color !

\ defer _draw-micros
\ : draw-micros
\     dup draw ['] _draw-micros swap each ;
\ ['] draw-micros is _draw-micros

: micros
    work> machines process machines decay
    show> 0 0 at machines ndraw ;

micros

\ Test
machines {
    64 64 at 
    \ %origin add { 

    %origin add { 
        16 16 at e{
            %ability add { 
                <enter> k !
                [: 64. 64. x 2! ;] kp !
            }
            \ %gravity add { }
            %move add { 
                16 16 at e{
                    %rep add { 
                        [: 1.0 val ! 360. rnd ang ! ;] xt !
                        16 16 at e{
                            %ability add { 
                                <enter> k !
                                [: 0. val ! ;] kp !
                                [: 1. val ! ." asdf" cr ;] kr !
                            }
                        e}
                    } 
                    %ability add { 
                        <enter> k !
                        [: 1. val ! ;] kh !
                    }
                \ %neuron add { 
                \ }
                \ %timeout add { }
                e} 
            }
        e}

    }

}
