\ ==============================================================================
\ Micro-codes
\ ==============================================================================

((
experiments into the idea of tiny modular bits of logic
(combining "Forth encourages you to not just slice, but dice" with explorative game development)

what's the idea?

tiny little workers (invisible in release mode) perform just one simple action continuously
  and networks of them manipulate each other to accomplish more advanced logic

it's basically a Godot-like node system, just a million times simpler
and also it will be much more tangible and intuitive

it's part of my "physicality" project
    - program games tangibly
    - minimal UI
    - workspace system
    - code is data


))

\ -- Dependencies --------------------------------------------------------------

REQUIRE %vfxland5%/forge/lib/dltree.vfx
REQUIRE %vfxland5%/supershow/traits.vfx
REQUIRE %vfxland5%/supershow/bitmap.vfx
REQUIRE %vfxland5%/supershow/sprites.vfx
REQUIRE %vfxland5%/supershow/tileset.vfx
REQUIRE %vfxland5%/supershow/autoload.vfx
REQUIRE %idir%/shapes.vfx
REQUIRE %idir%/arrow.vfx
REQUIRE %idir%/colors.vfx
REQUIRE %idir%/gui.vfx

\ -- Assets -------------------------------------------------------------------

\ allocator@ .name cr
BITMAP micro-icons.png
\ allocator@ .name cr
micro-icons.png 20 20 TILESET-FROM micro-icons.ts

8.5 constant ICON_RADIUS
24 constant ICON_SPACING

\ -- Traits -------------------------------------------------------------------

trait: %_micro
    :: _act    ( - ) ;
    :: _gather ( - ) ;
    :: act     ( - ) ;
    :: gather  ( - ) ;
    :: trigger ( - ) ;
    :: _hint    ( - a len ) s" " ;
trait;

\ TODO: Propagate IS-A and WORKS-WITH with classifier dependents
class: %element  works-with %_micro  class;
class: %panel  works-with %_micro  class;
class: %inspector  works-with %_micro  class;
class: %label  works-with %_micro  class;
class: %number  works-with %_micro  class;
class: %menu-item  works-with %_micro  class;
class: %menu  works-with %_micro  class;

trait: %animator
    prop anm 
    prop a.ts  prop a.spd  prop a.len
    prop a.ofs prop a.done prop a.flp
trait;

\ -- Base Class ---------------------------------------------------------------

ECONTEXT micro-ec

class: %micro
    %element derive
    128 field-space  \ enables in-place class changes
    prop en          \ user disable switch
    prop val :fixed  \ coefficient, must be >= 0.01 to process
    prop dcy :fixed  \ scalar
    prop upul :fixed  
    \ prop dpul :fixed
    \ prop lpul :fixed
    prop rpul :fixed
    prop org :ref %micro
    static icon-color \ rgba8
    static icon-bmp 
    is-a %_micro
    template { micro-ec ecp! in-heap en on 1.0 val ! 0.97 dcy ! -1 icon-color ! }
class;

\ -- Processing ---------------------------------------------------------------

: pulse-up    1.0 upul ! ;
\ : pulse-down  1.0 dpul ! ;
\ : pulse-left   1.0 lpul ! ;
: pulse-right  1.0 rpul ! ;

%micro :: gather
    en @ -exit
    ['] gather me each 
    val @ abs 0.01 >= if 
        me _gather 
    then ;

%micro :: act 
    en @ -exit
    val @ abs 0.01 >= if
        me _act
    then
    ['] act me each ;

|| 0.025 constant ps

: pulse- ( val. - val'. ) 
    dup 0> if ps - 0 max else ps + 0 min then ;

defer _decay
: decay ( micro - )
    as> 
        me %micro is? if
            en @ -exit
            dcy @ 0 1.0 clamp dcy !
            val @ abs 0.001 >= if val @ dcy @ p* val ! else 0 val ! then
            upul @ pulse- upul !
            \ dpul @ pulse- dpul !
            \ lpul @ pulse- lpul !
            rpul @ pulse- rpul !
        then
        ['] _decay me each ;
['] decay is _decay

: non-decaying  template { 1.0 dcy ! } ;

0 %micro :construct ( - )
    element:construct  micro-ec ecp! ;

\ -- Rendering ----------------------------------------------------------------

: val-alpha  $ffffff00 and  val @ abs 0 1.0 clamp 257.0 p/ or ;

: x-flow-color ( - )
\    $ff0000ff lpul @ mix 
    prev @ if $0000ffff prev @ >rpul @ mix then ;

: y-flow-color ( - )
    $ff0000ff upul @ mix ;
    \ parent @ if $80ffffff parent @ >dpul @ mix-rgba8 then ;

: changelen ( x1. y1. x2. y2. start. end. - x1'. y1'. x2'. y2'. )
    {: x1 y1 x2 y2 sc ec | ang :} 
    x1 y1 x2 y2 angle-to to ang
    x1 y1 ang 180.0 + sc vec 2+
    x2 y2 ang ec vec 2+ ;

: sibling-connector
    prev @ if
        prev @ %micro is? -exit
        $88ccff44 rgba8 x-flow-color
        prev @ { abspos } abspos ICON_RADIUS 1.0 + negate dup changelen
        2swap atp ->line
    then ;

: parent-connector
    parent @ if
        parent @ %micro is? -exit
        $ff888844 rgba8 y-flow-color
        abspos parent @ { abspos } ICON_RADIUS 1.0 + negate dup changelen
        2swap atp ->line
    then ;

: connectors
    e{ 1.0 thick sibling-connector parent-connector e} ;

: pulse@  upul @ ( dpul @ + ) ( lpul @ + ) rpul @ + 1.0 min ;

redef : icon
    pulse@ 0.01 > if
        white
        pulse@ 0 1.0 clamp ppena!
        9.5 circ     \ outer pulse circle
    then
    icon-color @ val-alpha rgba8 ICON_RADIUS circf  \ inner circle fill
    icon-color @ rgba8 ICON_RADIUS circ             \ inner circle rim
    icon-bmp @ cput ;

%micro :: .summary  
    object:.summary x 2p? ;

%micro :: _draw
    icon connectors ;

%micro :: click-box@
    abspos 9. 9. 2- 18. 18. box ;

\ -- Micro Classes -------------------------------------------------------------

c: %origin  %micro [non-decaying] ;

class: %move  %micro derive
    prop ang :fixed
    prop acc :fixed
class;  \ val = speed

c: %ability %micro k kp kh kr [non-decaying] ;

class: %rep  %micro derive  non-decaying
    \ val modulates speed
    prop dur :fixed
    prop t :fixed
    prop xt :xt     
    prop trg
class;  

class: %timeout   %micro derive  non-decaying
    \ val modulates speed
    prop dur :fixed
    prop t :fixed
    prop xt :xt
    prop trg
class;  

class: %hitbox  %micro derive  non-decaying
    prop w :fixed
    prop h :fixed
    prop lyr
    prop msk
    prop px :fixed
    prop py :fixed
class;

class: %neuron  %micro derive
    prop thr :fixed  \ value threshold
    prop tst :xt     \ executed during gather phase
    prop str :fixed  \ value to output after threshold is broken
    prop trg         \ whether the neuron also calls TRIGGER on the parent. defaults to true
class;

class: %rng  %micro derive  non-decaying
    prop noi         \ noise mode - outputs continuously if true
    prop ofs         \ output value offset
class;

c: %sprite  %micro %animator bmp [non-decaying] ; \ val modulates speed

\ -- Class Draw Methods --------------------------------------------------------

%origin :: _draw  
    icon ;

%sprite :: _draw
    bmp @ cput ;

%hitbox :: _draw
    icon
    white 0.5 ppena! w 2@ rect 
    connectors ;

%rep :: _hint ( - a len )
    dur @ f" %p" ;

%timeout :: _hint ( - a len )
    dur @ f" %p" ;

%ability :: _hint ( - a len )
    k @ f" %n" ;

: hint ( element - )
    {: me | a len :} 
    me _hint to len to a
    len -exit
    me { at-me }
    5 5 +at 
    black 0.5 ppena! a len print 
    -1 -1 +at
    white 0.9 ppena! a len print ;

\ %ability :: _draw
\     icon
\     _ability-key
\     connectors ;

defer __hints
: hints ( element - ) 
    context-menu if drop exit then
    [: dup hint __hints ;] swap each ;
' hints is __hints

\ -- Class Templates -----------------------------------------------------------

%hitbox >template { 16.0 16.0 w 2! }
%neuron >template { 1.0 thr ! 0 val ! 1.0 str ! trg on } 
%rep >template { 1.0 dur ! trg on }
%timeout >template { 1.0 dur ! trg on }
%move >template { 0 val ! }

\ -- Class Logic ------------------------------------------------------

%origin :: _process
    micro:gather   micro:act ;

\ stop processing gather/act at other origins.
%origin :: gather ;
%origin :: act ;

%move :: _act  
    acc @ val +!
    ang @ val @ vec parent @ >x 2+! 
    val @ abs 0.01 >= if pulse-up then ;

%ability :: _gather
    k @ pressed? if kp @ ?dup if pulse-up parent @ { execute } then then
    k @ held?    if kh @ ?dup if pulse-up parent @ { execute } then then
    k @ letgo?   if kr @ ?dup if pulse-up parent @ { execute } then then ;

%rep :: trigger
    pulse-up
    0 t !
    parent @ -exit
    trg @ if parent @ trigger then
    xt @ ?dup if parent @ { execute } then ;

%timeout :: trigger
    pulse-up
    0 t ! 0 val !
    parent @ -exit
    trg @ if parent @ trigger then    
    xt @ ?dup if parent @ { execute } then ;

%rep :: _gather 
    pdelta val @ abs p* t +! 
    t @ dur @ < ?exit
    me trigger ;

%timeout :: _gather 
    pdelta val @ abs p* t +! 
    t @ dur @ < ?exit
    me trigger ;

%sprite :: _act 
    anm @ -exit
    val @ advance-animation bmp ! ;

: calc-vel ( element - vx. vy. )
    >x 2@ px 2@ 2- ;

\ %hitbox :: _act
\     parent @ calc-vel vx 2!
\     abspos w 2@ box hit-test 
\     parent @ >x 2@ px 2! ;
 
%neuron :: trigger
    0 val ! 
    parent @ if
        str @ parent @ >val +!
        pulse-up
        trg @ if parent @ trigger then
    then ;

%neuron :: _gather
    tst @ ?execute
    val @ abs thr @ < ?exit
    me trigger ;

%neuron :: _hint ( - a len )
    trg @ if s" T" else s" " then ;

%rng :: trigger
    parent @ -exit
    2. rnd 1. - val @ p*  \ random -val to val
    ofs @ +               \ add offset
    parent @ >val +!
    pulse-up ;

%rng :: _gather
    noi @ -exit
    me trigger ;

%rng :: _hint ( - a len )
    noi @ if s" N" else s" " then ;

\ -- Lifecycle ----------------------------------------------------------------

0 0 at %desktop object machines
machines value last-origin

defer _delete-micro
: delete-micro ( micro - )
    >r 
    ['] _delete-micro r@ each
    r@ dlremove r> free throw ;
' delete-micro is _delete-micro

%micro :: delete  me delete-micro ;

\ -- Icon Configuration --------------------------------------------------------

|| : tile!  micro-icons.ts swap tile icon-bmp ! ;

%micro   >template { $00000080        icon-color !  0 icon-bmp ! }
%origin  >template { valof light-grey icon-color !  2  tile! }
%move    >template { valof cyan       icon-color !  0  tile! }
%ability >template { valof yellow     icon-color !  5  tile! }
%rep     >template { valof magenta    icon-color !  4  tile! }
%timeout >template { valof red        icon-color !  3  tile! }
%hitbox  >template { valof green      icon-color !  6  tile! }   
%neuron  >template { valof blue       icon-color !  1  tile! }
%rng     >template { valof purple     icon-color !  7  tile! }

\ -- Main Loop ----------------------------------------------------------------

: process-micros
    machines decay
    machines gui-input 
    machines process 
    machines sweep ;

: draw-micros
    0 0 at 
    machines draw 
    machines hints ;
    
: track-origin 
    <space> held? lmb held? and ?exit
    selection #items if
        selection peek %origin is? if
            selection peek to last-origin
        then
        last-origin {  
            abspos machines { abspos } 2- 
            2negate 
            \ winw winh 2>p 0.5 0.5 2p*   zoom @ >p dup 2p/   2+
            64. 64. 2+
            \ 2dup 2p. cr
            machines >x 2!
        }
    then
;

: micros
    microcodes>> machines as 
    2 user-zoom !
    work> 
        get-mouse process-micros
    show> 
        \ track-origin 
        draw-micros 
        gui-overlay 
        0 0 at micro-icons.png put ;

micros

\ -- DSL Syntax ---------------------------------------------------------------

\ || : level  parent @ dup if me swap indexof 1 + then ;
\ || : level ( - n )
\     {: | n :}
\     0 to n
\     prev @ begin ?dup while dup %origin is? not over #children 0> and if 1 +to n then >prev @ repeat 
\     n ;

|| : absy  abspos nip >i ;
|| 0 value next-y

: {{ ( micro - )
    { e{
    \ me .summary ." absolute: " abspos 2p. cr
    me %origin is? if
        0 ICON_SPACING at
        absy ICON_SPACING + to next-y
    else
        prev @ 0= if ICON_SPACING +to next-y then   \ first child advances Y
        0 next-y absy - at          \ Y relative to current object
    then ;

: }}
    me %origin is? not >r
    e} }
    r> if ICON_SPACING 0 +at then ;

\ -- Micro Context Menus -------------------------------------------------------

%micro :: _context-menu ( menu - )
    as>
    you [: en toggle ;] s" Toggle" +menu-item { }
    you [: ." TBD" cr ;] s" Change" +menu-item { }
    +clone-option
    +attach-option
    +detach-option
    +delete-option 
;


