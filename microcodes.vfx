((
micro-codes

experiments into the idea of tiny modular bits of logic
(combining "Forth encourages you to not just slice, but dice" with explorative game development)

what's the idea?

tiny little workers (invisible in release mode) perform just one simple action continuously
  and networks of them manipulate each other to accomplish more advanced logic

it's basically a Godot-like node system, just a million times simpler
and also it will be much more tangible and intuitive

it's part of my "physicality" project
    - program games tangibly
    - minimal UI
    - workspace system
    - code is data


))

require %vfxland5%/forge/lib/dltree.vfx
require %vfxland5%/supershow/traits.vfx
require %vfxland5%/supershow/bitmap.vfx
require %vfxland5%/supershow/sprites.vfx
require %vfxland5%/supershow/tileset.vfx
require %vfxland5%/supershow/autoload.vfx
require %idir%/shapes.vfx
require %idir%/colors.vfx

bitmap micro-icons.png
micro-icons.png 20 20 tileset-from micro-icons.ts

trait: %element
    is-a %dltree
    is-a %drawable
    prop x :fixed
    prop y :fixed
    :: clickbox@ ( - x1 y1 x2 y2 ) $DEADBEEF dup dup dup ;
trait;

: abspos  x 2@ me begin >parent @ ?dup while { x 2@ 2+ me } repeat ;
: box  2over 2+ ;

trait: %micro-like
    is-a %element
    is-a %unloadable
    :: action  ( - ) ;
    :: trigger ( - ) ;
    prop en          \ user disable switch
    prop unloaded
    prop val :fixed  \ coefficient, must be >= 0.01 to process
    prop dcy :fixed  \ scalar
    prop upul :fixed  
    \ prop dpul :fixed
    prop lpul :fixed
    prop rpul :fixed
    static icon-color \ rgba8
    static icon-bmp 
trait;

: pulse-up    1.0 upul ! ;
\ : pulse-down  1.0 dpul ! ;
: pulse-left   1.0 lpul ! ;
: pulse-right  1.0 rpul ! ;

trait: %animator
    prop anm 
    prop a.ts  prop a.spd  prop a.len
    prop a.ofs prop a.done prop a.flp
trait;

ECONTEXT micro-ec

class: %micro
    128 field-space
    is-a %micro-like
    template { micro-ec ecp! in-heap en on 1.0 val ! 0.97 dcy ! -1 icon-color ! }
class;

defer _process
: process ( micro - )
    as> en @ -exit
        val @ 0.01 >= if 
            me action 
        then
        ['] _process me each ;
['] process is _process

|| 0.025 constant ps

defer _decay
: decay ( micro - )
    as> en @ -exit
        val @ 0.01 >= if val @ dcy @ p* val ! then
        upul @ dup 0> if ps - 0 max else ps + 0 min then upul !
        \ dpul @ dup 0> if ps - 0 max else ps + 0 min then dpul !
        lpul @ dup 0> if ps - 0 max else ps + 0 min then lpul !
        rpul @ dup 0> if ps - 0 max else ps + 0 min then rpul !
        ['] _decay me each ;
['] decay is _decay

: non-decaying  template { 1.0 dcy ! } ;

0 %micro :construct ( - )
    at@p x 2!  micro-ec ecp! ;

%micro :: unload ( - )
    unloaded on ;

: val-alpha  $ffffff00 and  val @ 257.0 p/ or ;

: x-flow-color ( - )
    $ff0000ff lpul @ mix 
    prev @ if $0000ffff prev @ >rpul @ mix then ;

: y-flow-color ( - )
    $ff0000ff upul @ mix ;
    \ parent @ if $80ffffff parent @ >dpul @ mix-rgba8 then ;
    
: sibling-connector
    prev @ if
        prev @ { abspos } brown 0.5 ppena! x-flow-color line
    then ;

: parent-connector
    parent @ if
        parent @ { abspos } grey 0.5 ppena! y-flow-color line
    then ;

: connectors
    sibling-connector parent-connector ;

: pulse@  upul @ ( dpul @ + ) lpul @ + rpul @ + 1.0 min ;

redef : icon
    abspos 2>i at
    pulse@ 0.01 > if
        icon-color @ $ffffff00 and pulse@ 257.0 p/ or rgba8
        10. circ  \ outer pulse circle
    then
    icon-color @ val-alpha rgba8 8.5 circf
    icon-color @ rgba8 8.5 circ 
    icon-bmp @ cput ;

%micro :: .summary  object:.summary x 2p? ;

%micro :: draw
    icon connectors ;

c: %origin  %micro [non-decaying] ; 
c: %move    %micro ang acc ; \ val = speed
c: %ability %micro k kp kh kr [non-decaying] ; 
c: %rep     %micro dur t xt [non-decaying] ; \ val modulates speed
c: %timeout %micro dur t xt [non-decaying] ; \ val modulates speed
c: %hitbox  %micro w h lyr msk px py [non-decaying] ;
c: %neuron  %micro thr tst ;
c: %sprite  %micro %animator bmp [non-decaying] ; \ val modulates speed 

%origin :: clickbox@  
    abspos 16. 16. box ;

%origin :: draw  
    icon ;

%sprite :: draw  
    abspos 2>i at   bmp @ cput ;

%hitbox :: draw
    icon
    white w 2@ rect 
    connectors ;

\ require %vfxland5%/forge/lib/allegro5/vga13h.vfx
\ init-vga-font

: _ability-key
    abspos 2>i at 8 8 +at 
    black 0.5 ppena! k @ f" %n" print 
    -1 -1 +at
    white 0.9 ppena! k @ f" %n" print ;

\ %ability :: draw
\     icon
\     _ability-key
\     connectors ;

%hitbox >template { 16.0 16.0 w 2! }
%neuron >template { 2.0 thr ! 0.999 dcy ! } 
%rep >template { 1.0 dur ! }
%timeout >template { 1.0 dur ! }

\ class: %panel
\     is-a %element
\     :: clickbox@ abspos w 2@ box ;
\ class;

\ class: %inspector
\     %panel derive
\ class;

\ : performs: >template { :noname action ! } ;
\ : perform  action ! ;

%move :: action  
    acc @ val +!
    ang @ val @ vec parent @ >x 2+! 
    val @ 0.01 >= if pulse-up then ;

c: %gravity %move [non-decaying] ;
%gravity >template { 90. ang ! 0.03 acc ! }

%ability :: action
    k @ pressed? if pulse-up kp @ parent @ { ?execute } then
    k @ held?    if pulse-up kh @ parent @ { ?execute } then
    k @ letgo?   if pulse-up kr @ parent @ { ?execute } then ;

%rep :: trigger
    pulse-up
    0 t !
    xt @ parent @ { ?execute } ;

%rep :: action 
    pdelta val @ p* t +! 
    t @ dur @ < ?exit
    me trigger ;

%timeout :: trigger
    pulse-up
    0 t ! 0 val !
    xt @ parent @ { ?execute } ;

%timeout :: action 
    pdelta val @ p* t +! 
    t @ dur @ < ?exit
    me trigger ;

%sprite :: action 
    anm @ -exit
    val @ advance-animation bmp ! ;

: calc-vel ( element - vx. vy. )
    >x 2@ px 2@ 2- ;

\ %hitbox :: action
\     parent @ calc-vel vx 2!
\     abspos w 2@ box hit-test 
\     parent @ >x 2@ px 2! ;
 
%neuron :: action
    tst @ ?execute
    val @ thr @ >=
    next @ if
        dup next @ >val +!
        pulse-right
    then
    if 0 val ! then ;

0 0 at %micro object machines
    machines { 1.0 dcy ! }


defer _delete-micro
: delete-micro ( micro - )
    >r 
    ['] _delete-micro r@ each
    r@ dlremove r> free throw ;
' delete-micro is _delete-micro

|| : sweep ( iterable - )
    [: { unloaded @ if me delete-micro then } ;] swap each ;

%micro :: vacate
    ['] unload me each  me sweep ;


|| : tile!  micro-icons.ts swap tile icon-bmp ! ;

%micro   >template { 0                icon-color !  0 icon-bmp ! }
%origin  >template { valof light-grey icon-color !  2  tile! }
%move    >template { valof cyan       icon-color !  0  tile! }
%ability >template { valof yellow     icon-color !  5  tile! }
%rep     >template { valof magenta    icon-color !  4  tile! }
%timeout >template { valof red        icon-color !  3  tile! }
%hitbox  >template { valof green      icon-color !  6  tile! }   
%neuron  >template { valof blue       icon-color !  1  tile! }   

defer _ability-keys
: ability-keys
    [: { me %ability is? if _ability-key then me _ability-keys } ;] swap each ;
' ability-keys is _ability-keys

: micros
    microcodes>> machines as 
    work> machines process machines sweep
    show> 
        0 0 at 
        machines ndraw 
        machines ability-keys
        machines decay ;

micros

: {{  { e{ 0 20 at ;
: }}  e} } 20 0 +at ;

: *kpress ( key xt - ability )
    %ability add { kp ! k ! me } ;

\ Test
: *rando
    %origin add {
        0 20 at
        <del> [: me unload ;] *kpress {{ }}
        <enter> [: 64. 64. x 2! ;] *kpress {{ }}
        \ %gravity add { }
        %move add {{ 
            %rep add {{
                [: 1.0 val ! 360. rnd ang ! ;] xt !
                %ability add {{
                    <enter> k !
                    [: 0. val ! ;] kp !
                    [: 1. val ! me trigger ;] kr !
                }}
            }}
            %ability add {{
                <enter> k !
                [: 1. val ! ;] kh !
            }}
        }}
    me } ;

: test 
    machines {{
        64 64 at 
        *rando {{
            *rando {{ }}
        }}
        *rando {{
            *rando {{ }}
        }}
        *rando {{
            *rando {{ }}
        }}
        *rando {{
            *rando {{ }}
        }}
        32 200 at
        %origin add {{ 
            en off
            %move add {{ }}
            %ability add {{ }}
            %rep add {{ }}
            %timeout add {{ }}
            %neuron add {{ }}
            %hitbox add {{ }} \ -8. -8. x 2+!  16. 16. w 2! }}
        }}
    }}
;

test