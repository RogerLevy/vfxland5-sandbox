\ ==============================================================================
\ Micros
\ ==============================================================================

((
experiments into the idea of tiny modular bits of logic
(combining "Forth encourages you to not just slice, but dice" with explorative game development)

what's the idea?

tiny little workers (invisible in release mode) perform just one simple action continuously
  and networks of them manipulate each other to accomplish more advanced logic

it's basically a Godot-like node system, just a million times simpler
and also it will be much more tangible and intuitive

it's part of my "physicality" project
    - program games tangibly
    - minimal UI
    - workspace system
    - code is data


))

\ -- Dependencies --------------------------------------------------------------

REQUIRE %vfxland5%/forge/lib/dltree.vfx
REQUIRE %vfxland5%/supershow/traits.vfx
REQUIRE %vfxland5%/supershow/bitmap.vfx
REQUIRE %vfxland5%/supershow/sprites.vfx
REQUIRE %vfxland5%/supershow/tileset.vfx
REQUIRE %vfxland5%/supershow/autoload.vfx
REQUIRE %idir%/shapes.vfx
REQUIRE %idir%/arrow.vfx
REQUIRE %idir%/colors.vfx

\ -- Variables------------------------------------------------------------------

BITMAP %idir%/micro-icons.png
micro-icons.png 20 20 TILESET-FROM micro-icons.ts

8.5 constant ICON_RADIUS
24 constant ICON_SPACING

\ -- Traits -------------------------------------------------------------------

REQUIRE %idir%/element.vfx

trait: %_micro
    :: _act    ( - ) ;
    :: _gather ( - ) ;
    :: act     ( - ) ;
    :: gather  ( - ) ;
    :: _hint   ( - a len ) s" " ;
    :: trigger ( - ) ;
    :: render  ( - ) ;
trait;

\ TODO: Propagate IS-A and WORKS-WITH with classifier dependents
class: %element  works-with %_micro  class;
class: %inspector  works-with %_micro  class;

REQUIRE %idir%/gui.vfx
REQUIRE %idir%/session.vfx

trait: %animator
    prop anm <readonly
    prop a.ts <readonly  
    prop a.spd :fixed
    prop a.len
    prop a.ofs :fixed
    prop a.done 
    prop a.flp
trait;

\ -- Base Class ---------------------------------------------------------------

\ ECONTEXT micro-ec

class: %micro
    %element derive
    128 field-space  \ enables in-place class changes
    prop en <save          \ user disable switch
    prop val :fixed <save  \ coefficient, must be >= 0.01 to process
    prop dcy :fixed <save  \ scalar
    prop upul :fixed <readonly      \ aesthetic only - not saved
    prop rpul :fixed <readonly      \ aesthetic only - not saved
    static icon-color \ rgba8
    static icon-bmp
    is-a %_micro
    template { in-heap en on 1.0 val ! 0.97 dcy ! -1 icon-color ! }
    :: handy? true ;
class;

\ -- Processing ---------------------------------------------------------------

: pulse-up    1.0 upul ! ;
\ : pulse-down  1.0 dpul ! ;
\ : pulse-left   1.0 lpul ! ;
: pulse-right  1.0 rpul ! ;

%micro :: gather
    en @ -exit
    ['] gather me each 
    val @ abs 0.01 >= if 
        me _gather 
    then ;

%micro :: act 
    en @ -exit
    val @ abs 0.01 >= if
        me _act
    then
    ['] act me each ;

|| 0.05 constant ps

: pulse- ( val. - val'. ) 
    dup 0> if ps - 0 max else ps + 0 min then ;

defer _decay
: decay ( micro - )
    as> 
        me %micro is? if
            en @ -exit
            dcy @ 0 1.0 clamp dcy !
            val @ abs 0.001 >= if val @ dcy @ p* val ! else 0 val ! then
            upul @ pulse- upul !
            \ dpul @ pulse- dpul !
            \ lpul @ pulse- lpul !
            rpul @ pulse- rpul !
        then
        ['] _decay me each ;
['] decay is _decay

: non-decaying  template { 1.0 dcy ! } ;

0 %micro :construct ( - )
    element:construct  ; \ micro-ec ecp! ;

\ -- Rendering ----------------------------------------------------------------

: val-alpha  $ffffff00 and  val @ abs 0 1.0 clamp 257.0 p/ or ;

: x-flow-color ( - )
\    $ff0000ff lpul @ mix 
    prev @ if $0000ffff prev @ >rpul @ mix then ;

: y-flow-color ( - )
    $ff0000ff upul @ mix ;
    \ parent @ if $80ffffff parent @ >dpul @ mix-rgba8 then ;

: changelen ( x1. y1. x2. y2. start. end. - x1'. y1'. x2'. y2'. )
    {: x1 y1 x2 y2 sc ec | ang :} 
    x1 y1 x2 y2 angle-to to ang
    x1 y1 ang 180.0 + sc vec 2+
    x2 y2 ang ec vec 2+ ;

: sibling-connector
    prev @ if
        prev @ %micro is? -exit
        $88ccff44 rgba8 x-flow-color
        prev @ { abspos } abspos ICON_RADIUS 1.0 + negate dup changelen
        2swap atp ->line
    then ;

: parent-connector
    parent @ if
        parent @ %micro is? -exit
        $ff888844 rgba8 y-flow-color
        abspos parent @ { abspos } ICON_RADIUS 1.0 + negate dup changelen
        2swap atp ->line
    then ;

: connectors
    e{ 1.0 thick sibling-connector parent-connector e} ;

: pulse@  upul @ ( dpul @ + ) ( lpul @ + ) rpul @ + 1.0 min ;

: hint ( element - )
    {: me | a len :} 
    me _hint to len to a
    len -exit
    me { at-me }
    5 5 +at 
    black 0.5 ppena! a len print 
    -1 -1 +at
    white 0.9 ppena! a len print ;

\ defer __hints
\ : hints ( element - ) 
\     context-menu if drop exit then
\     [: dup hint __hints ;] swap each ;
\ ' hints is __hints

redef : icon
    pulse@ 0.01 > if
        white
        pulse@ 0 1.0 clamp ppena!
        9.5 circ     \ outer pulse circle
    then
    icon-color @ val-alpha rgba8 ICON_RADIUS circf  \ inner circle fill
    icon-color @ rgba8 ICON_RADIUS circ             \ inner circle rim
    icon-bmp @ cput 
    context-menu not if me hint then ;

%micro :: _draw
    icon connectors ;

%micro :: click-box@
    abspos 9. 9. 2- 18. 18. box ;

\ -- Micro Classes -------------------------------------------------------------

class: %origin  %micro derive  non-decaying
    prop rx :fixed <save  \ remote x,y
    prop ry :fixed <save
    prop w :fixed <save
    prop h :fixed <save
class;

\ : rabspos ( - x. y. )
\     rx 2@ me begin >parent @ ?dup while { rx 2@ 2+ me } repeat ;

: origin@ ( - origin|0 )
    me begin dup %origin is? not while >parent @ dup -exit repeat ;

class: %move  %micro derive
    prop ang :fixed <save
    prop acc :fixed <save
class;  \ val = speed

class: %ability  %micro derive  non-decaying
    prop k <save           \ key code to monitor
    prop kp :xt            \ code ref - not saved
    prop kh :xt            \ code ref - not saved
    prop kr :xt            \ code ref - not saved
class;

class: %rep  %micro derive  non-decaying
    \ val modulates speed
    prop dur :fixed <save
    prop t :fixed          \ transient timer - not saved
    prop xt :xt            \ code ref - not saved
    prop trg <save
class;  

class: %timeout   %micro derive  non-decaying
    \ val modulates speed
    prop dur :fixed <save
    prop t :fixed          \ transient timer - not saved
    prop xt :xt            \ code ref - not saved
    prop trg <save
class;  

class: %hitbox  %micro derive  non-decaying
    prop w :fixed <save
    prop h :fixed <save
    prop lyr <save
    prop msk <save
    prop px :fixed         \ transient velocity - not saved
    prop py :fixed         \ transient velocity - not saved
class;

class: %neuron  %micro derive
    prop thr :fixed <save  \ value threshold
    prop tst :xt           \ code ref - not saved
    prop str :fixed <save  \ value to output after threshold is broken
    prop trg <save         \ whether the neuron also calls TRIGGER on the parent
class;

class: %rng  %micro derive  non-decaying
    prop noi <save         \ noise mode - outputs continuously if true
    prop ofs <save         \ output value offset
class;

class: %sprite  %origin derive  non-decaying   \ val modulates speed
    is-a %animator 
    prop bmp 
    prop flp <save
class;

\ -- Defaults ------------------------------------------------------------------

%hitbox >template { 16.0 16.0 w 2! }
%neuron >template { 1.0 thr ! 0 val ! 1.0 str ! trg on } 
%rep >template { 1.0 dur ! trg on }
%timeout >template { 1.0 dur ! trg on }
%move >template { 0 val ! }
%origin >template { 100. 100. w 2! }

\ -- Icon Configuration --------------------------------------------------------

|| : tile!  micro-icons.ts swap tile icon-bmp ! ;

%micro   >template { $00000080        icon-color !  0 icon-bmp ! }
%origin  >template { valof light-grey icon-color !  2 tile! }
%move    >template { valof cyan       icon-color !  0 tile! }
%ability >template { valof yellow     icon-color !  5 tile! }
%rep     >template { valof magenta    icon-color !  4 tile! }
%timeout >template { valof red        icon-color !  3 tile! }
%hitbox  >template { valof green      icon-color !  6 tile! }   
%neuron  >template { valof blue       icon-color !  1 tile! }
%rng     >template { valof purple     icon-color !  7 tile! }
%sprite  >template { valof white      icon-color !  0 icon-bmp ! }

\ -- Class Draw Methods --------------------------------------------------------

%origin :: click-box@
    abspos w 2@ 2 2 2/ 2-`` w 2@`` box ;

%origin :: _draw  
    w 2@ 2>i -2 -2 2/ +at 
    black see-thru w 2@ rectf
    at-me
    icon-bmp @ cput
    connectors ;

|| : ?flip  flp @ 24 << or ; 

%sprite :: _draw
    bmp @ ?dup if ?flip cput else icon then ;
    \ connectors ;

\ %hitbox :: click-box@
\     abspos w 2@`` box ;

%hitbox :: _draw  
    white see-thru w 2@ rectf
    at-me
    icon ;
    \ connectors ;

%rep :: _hint ( - a len )
    dur @ f" %p" ;

%timeout :: _hint ( - a len )
    dur @ f" %p" ;

%ability :: _hint ( - a len )
    k @ f" %n" ;

\ -- Micro rendering -----------------------------------------------------------

%element :: render
    ['] render me each ;

%origin :: render 
    <at rx 2@ 2>i 2dup +at ['] render me each 2negate +at ;

%sprite :: render 
    en @ -exit  
    <at 
    origin@ relpos 2>i 2dup +at 
    bmp @ cput 
    ['] render me each 
    2negate +at ;

\ -- Class Logic ------------------------------------------------------

%origin :: _process
    micro:gather   micro:act ;

\ stop processing gather/act at other origins.
%origin :: gather ;
%origin :: act ;

%move :: _act  
    acc @ val +!
    parent @ ?dup if
        dup %origin is? if
            ang @ val @ vec rot >rx 2+!
            val @ abs 0.01 >= if pulse-up then
        else drop then
    then ;

%ability :: _gather
    k @ pressed? if kp @ ?dup if pulse-up parent @ { execute } then then
    k @ held?    if kh @ ?dup if pulse-up parent @ { execute } then then
    k @ letgo?   if kr @ ?dup if pulse-up parent @ { execute } then then ;

%rep :: trigger
    pulse-up
    0 t !
    parent @ -exit
    trg @ if parent @ trigger then
    xt @ ?dup if parent @ { execute } then ;

%timeout :: trigger
    pulse-up
    0 t ! 0 val !
    parent @ -exit
    trg @ if parent @ trigger then    
    xt @ ?dup if parent @ { execute } then ;

%rep :: _gather 
    pdelta val @ abs p* t +! 
    t @ dur @ < ?exit
    me trigger ;

%timeout :: _gather 
    pdelta val @ abs p* t +! 
    t @ dur @ < ?exit
    me trigger ;

%sprite :: click-box@ ( - x1. y1. x2. y2. )
    abspos bmp @ bmpwh 2>p 2 2 2/ 2-
    bmp @ bmpwh 2>p box ;

%sprite :: _mousedown ( btn - )
    rmb = -exit
    using? if me open-context-menu then ;

%sprite :: _act 
    anm @ -exit
    val @ advance-animation bmp ! ;

%sprite :: forth@ ( - a len )
    bmp @ 0= if s" " exit then 
    bmp @ is-tile? if 
        bmp @ bmp>parent bmp>ts$
        dup 0 tile bmp @ swap -`
        swap body>name``
        f" %s %n tile bmp !"
        exit
    then  
    bmp @ bitmap-file -path
    f" %s bmp !" ;

: calc-vel ( element - vx. vy. )
    >x 2@ px 2@ 2- ;

\ %hitbox :: _act
\     parent @ calc-vel vx 2!
\     abspos w 2@ box hit-test 
\     parent @ >x 2@ px 2! ;
 
%neuron :: trigger
    0 val ! 
    parent @ if
        str @ parent @ >val +!
        pulse-up
        trg @ if parent @ trigger then
    then ;

%neuron :: _gather
    tst @ ?execute
    val @ abs thr @ < ?exit
    me trigger ;

%neuron :: _hint ( - a len )
    trg @ if s" T" else s" " then ;

%rng :: trigger
    parent @ -exit
    2. rnd 1. - val @ p*  \ random -val to val
    ofs @ +               \ add offset
    parent @ >val +!
    pulse-up ;

%rng :: _gather
    noi @ -exit
    me trigger ;

%rng :: _hint ( - a len )
    noi @ if s" N" else s" " then ;

\ -- Lifecycle ----------------------------------------------------------------

0 0 at %desktop dmake value desktop
desktop session push
hud session push

%desktop :: active? ( - flag )
    desktop me = ;

%desktop :: forth@ ( - a len )
    desktop me = if s" me to desktop" else s" " then ;

defer _delete-micro
: delete-micro ( micro - )
    >r 
    ['] _delete-micro r@ each
    r@ dlremove r> free throw ;
' delete-micro is _delete-micro

%micro :: delete  me delete-micro ;

\ -- DSL Syntax ---------------------------------------------------------------

\ || : level  parent @ dup if me swap indexof 1 + then ;
\ || : level ( - n )
\     {: | n :}
\     0 to n
\     prev @ begin ?dup while dup %origin is? not over #children 0> and if 1 +to n then >prev @ repeat 
\     n ;

|| : absy  abspos nip >i ;
|| 0 value next-y

: {{ ( micro - )
    { e{
    \ me .summary ." absolute: " abspos 2p. cr
    me %origin is? if
        0 ICON_SPACING at
        absy ICON_SPACING + to next-y
    else
        prev @ 0= if ICON_SPACING +to next-y then   \ first child advances Y
        0 next-y absy - at          \ Y relative to current object
    then ;

: }}
    me %origin is? not >r
    e} }
    r> if ICON_SPACING 0 +at then ;

\ -- Micro Context Menus -------------------------------------------------------

: toggle,
    you [: en toggle ;] you >en @ if s" Disable" else s" Enable" then option ;

: change,
    you [: ." TBD" cr ;] s" Change (TBD)" option ;

%micro :: _context-menu ( menu - )
    as>
    toggle,
    change,
    common-options,
;
