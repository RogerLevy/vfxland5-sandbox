REQUIRE %vfxland5%/forge/lib/dltree.vfx
REQUIRE %vfxland5%/cjson/cjson2.vfx
REQUIRE %vfxland5%/supershow/traits.vfx

ECONTEXT gui-ec
0 value hovered
0 value focused   \ Element with keyboard focus
1024 %addr stack selection

: this ( - element|0 ) selection #items dup -exit drop selection peek ;

redef : *lstring ( a n - a' )
    dup cell+ 256 max allocate throw >r r@ lplace r> ;

\ -- Base Trait ----------------------------------------------------------------

trait: %_element
    is-a %dltree
    is-a %drawable
    is-a %unloadable
    is-a %xy
    prop flags <save <readonly
    prop script :lstring 
    :: click-box@ ( - x1. y1. x2. y2. ) $DEADBEEF dup dup dup ;
    :: script@ ( - a len ) script @ ?dup if lcount else s" " then ;
    \ :: _click ( n - ) drop ;
    :: _enter ( - ) ;
    :: _leave ( - ) ;
    :: _mousedown ( btn - ) drop ;  \ lbm , rmb , or mmb
    :: _mousewheel ( n - ) drop ;   \ delta
    \ :: _mouseup ( btn - ) drop ;
    \ :: _mousemove ( - ) ;
    :: _process ( - ) ;
    :: process ( - ) ;
    :: _draw ( - ) ;
    :: delete ( - ) stub ;
    \ :: draggable? ( - flag ) true ;
    :: active? ( - flag ) true ;
    :: handy? ( - flag ) false ;  \ Override to make element always draggable/context-menuable
    :: _context-menu ( menu - ) drop ;   \ override to add items / customize the menu
    :: on-clone ( - ) ;
    :: on-attach ( - ) ;
    :: on-focus ( - ) ;       \ Called when element gains keyboard focus
    :: on-blur ( - ) ;        \ Called when element loses keyboard focus
    :: _keydown ( key - ) drop ;  \ Single key press (no repeat)
    :: _keychar ( key - ) drop ;  \ Key with repeat
    :: open ( - ) ;
    :: close ( - ) ;
    redef :: cursor ( - ) stub ;
    :: clear ( - ) stub ;
    redef :: save ( - ) ;
    :: revert ( - ) ;
    :: click ( btn - ) drop ;
trait;

\ -- Helpers -------------------------------------------------------------------

: +unloaded  0 flags set-bit ;
: unloaded?  0 flags test-bit ;
: +bolted    1 flags set-bit ;
: -bolted    1 flags reset-bit ;
: bolted?    1 flags test-bit ;
: +clipped   2 flags set-bit ;
: -clipped   2 flags reset-bit ;
: clipped?   2 flags test-bit ;
: +closed    3 flags set-bit ;
: -closed    3 flags reset-bit ;
: closed?    3 flags test-bit ;
: opened?    closed? not ;
: +temporary 4 flags set-bit ;
: -temporary 4 flags reset-bit ;
: temporary? 4 flags test-bit ;

: abspos  x 2@ me begin >parent @ ?dup while { x 2@ 2+ me } repeat ;
: at-me  abspos atp ;
: box  2over 2+ ;
: ?push  2dup contains? if 2drop exit then push ;
: see-thru   0.6 ppena! ;
: click-dims  click-box@ 2swap 2- ;

: load-script ( path len - )
    expand slashes >pad count required ;

: set-script ( path len - )
    2dup *lstring script ! load-script ;

: memoize-include ( <path> - )
    me %_element is? not abort" Current object is not an element."
    bl parse set-script ;

: >root ( element - root )
    begin dup >parent @ ?dup while nip repeat ;

: from-element ( absx absy element - )
    { abspos } 2>i 2- at ;

: relpos ( element - x. y. )
    { abspos } abspos 2swap 2- ;

\ -- Focus System --------------------------------------------------------------

: focus ( element - )
    focused ?dup if on-blur then
    dup to focused
    ?dup if on-focus then ;

: unfocus ( - )
    0 focus ;

: unfocus-if-descendant ( ancestor - )
    focused 0= if drop exit then
    focused swap descendant? if unfocus then ;

: deselect-if-descendant ( ancestor - )
    selection #items 0= if drop exit then
    this swap descendant? if selection vacate then ;

\ -- Element Class -------------------------------------------------------------

class: %element
    is-a %_element
    template { gui-ec ecp! in-heap }
class;

%element :: open     -closed ;
%element :: close    +closed  me unfocus-if-descendant  me deselect-if-descendant ;

%element :: .summary  
    object:.summary x 2p? ;

0 %element :construct ( - )
    at@p x 2!  gui-ec ecp! in-heap ;

: delete-element ( element - )
    dup hovered = if 0 to hovered then
    dup { ['] delete me each }   \ recursively delete children
    \ dup selection contains? if dup selection remove then
    dup >script @ free drop      \ free script lstring
    dup dlremove free drop ;

%element :: delete
    me focused = if 0 to focused then 
    me delete-element ;

\ -- Element Methods -----------------------------------------------------------

%element :: unload ( - )
    +unloaded 
    selection vacate 
    0 to hovered ;

defer _sweep
redef : sweep ( iterable - )
    [: dup _sweep { unloaded? if me delete then } ;] swap each ;
['] sweep is _sweep

%element :: vacate
    ['] unload me each  me sweep ;

%element :: push
    dup %_element is? not abort" ELEMENT:PUSH : Source is not an element."
    dup dltree:push on-attach ;

%element :: insert-under
    dup %_element is? not abort" ELEMENT:INSERT-UNDER : Source is not an element."
    dltree:insert-under ;

%element :: insert-over
    dup %_element is? not abort" ELEMENT:INSERT-OVER : Source is not an element."
    dltree:insert-over ;

%element :: unshift
    dup %_element is? not abort" ELEMENT:UNSHIFT : Source is not an element."
    dltree:unshift ;

%element :: process ( - )
    me active? -exit
    me _process
    opened? -exit
    ['] process me each ;

: zoom*  zoom @ dup 2* ;

%element :: draw
    me active? -exit
    \ TODO: fix this workaround
    vga-8x8 fnt!
    at-me  
    me _draw 

    opened? -exit
    clipped? if
        0 0 0 0 sp@ 3 cells + dup cell- dup cell- dup cell- al_get_clipping_rectangle
        me click-box@ 2>i zoom* 2swap 2>i zoom* 2swap    2over 2- al_set_clipping_rectangle
        2>r 2>r
        ['] draw me each 
        2r> 2r>
        al_set_clipping_rectangle
    else
        ['] draw me each 
    then 
;

%element :: clear
    ['] unload me each
    going @ not if me sweep then
    0 to hovered
    0 to focused
    selection vacate ;

\ -- Clone ---------------------------------------------------------------------

: clone ( element - element' )
    as> \ scope into object. establishes EC
        cla @ make {     \ create new instance of same class
            you me dup sizeof move  \ copy data
            0 dup dup dup dup
            parent ! prev ! next ! lowest ! highest !
            0 item-count !
            script @ ?dup if lcount *lstring script ! then
            me on-clone
        me } ;

defer _deep-clone
: deep-clone ( element - element' )
    dup clone swap
    [: _deep-clone over push ;] swap each ;
' deep-clone is _deep-clone
