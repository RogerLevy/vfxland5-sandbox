\ =============================================================================
\ GUI
\ =============================================================================

\ -- Dependencies --------------------------------------------------------------

REQUIRE %vfxland5%/forge/lib/dltree.vfx
REQUIRE %vfxland5%/lib/mouse.vfx
REQUIRE %idir%/shapes.vfx
REQUIRE %idir%/colors.vfx
REQUIRE %idir%/element.vfx
REQUIRE %idir%/save.vfx

: white-connector ( element - )
    abspos atp 1.0 thick $ffffff44 rgba8
    { abspos } ->line ;

\ -- Mode Toggle (F12) ---------------------------------------------------------

variable using-mode   \ false = designing (default), true = using

: designing? ( - flag ) using-mode @ not ;
: using? ( - flag ) using-mode @ ;

: toggle-mode ( - ) 
    using-mode @ not using-mode ! 
    using? if ." === USE MODE ===" cr 
    else ." === DESIGN MODE ===" cr then  ;

\ -- Cursors -------------------------------------------------------------------

BITMAP cursors.png
cursors.png 32 32 TILESET-FROM cursors.ts
variable use-cursor
variable design-cursor   
0 constant pointer
1 constant hammer  hammer design-cursor !
2 constant hand

: draw-cursor  
    mouse at 
    cursors.ts using? if use-cursor @ else design-cursor @ then tile cput ;

\ -- Desktop -------------------------------------------------------------------

class: %desktop
    %element derive
    prop clr <save
    template { valof dark-grey clr ! +bolted }

    :: click-box@ 0 0 winw winh 2>p ;
    :: _process 
        <space> held? if
            hand use-cursor !
            hand design-cursor !
            lmb? if mickey 2>p x 2+! then 
        else 
            pointer use-cursor !
            hammer design-cursor ! 
        then ;
    :: _draw 0 0 at clr @ rgba8 winw winh 2>p rectf ;
class;

\ -- UI Box --------------------------------------------------------------------

class: %ui-box
    %element derive

    prop w :fixed <save
    prop h :fixed <save

    template { 100. 100. w 2! } 

    EC_MAX_SIZE nprop ec  template { ec clear-ec }

    :: click-box@ ( - x1 y1 x2 y2 ) abspos w 2@ box ;

class;

0 %ui-box :construct ( - )
    at@p x 2!   ec ecp! in-heap ;

\ -- Selection -----------------------------------------------------------------

: +select  ( element - ) selection ?push ;
: select   ( element - ) selection vacate selection push ;
: this     ( - element ) selection peek ;

\ -- Panel ---------------------------------------------------------------------

class: %panel
    %ui-box derive
    prop clr <save
    template { black see-thru rgba8@ clr ! }
    :: _draw  clr @ rgba8 w 2@ rectf ;
class;

\ -- Textual Trait -------------------------------------------------------------

trait: %textual
    prop txt :lstring <save  \ heap-allocated lstring
    prop fnt :addr 
    prop w :fixed
    prop h :fixed
    prop tx :fixed  \ text offset
    prop ty :fixed

    : _update-box  
        fnt @ fnt!  txt @ lcount textbox 2>p w 2! 2>p tx 2! ;

    :: text! ( a n - ) 
        dup 0< if 2drop exit then
        txt @ >r 
        *lstring txt !
        _update-box 
        r> free drop \ ignore ior 
    ;

    :: add-char ( n - )
        txt @ lcount cell+ -4 u+ 1 + resize throw txt !
        ( n ) pad c!  pad 1 txt @ lappend 
        _update-box ;

    :: text@ ( - a len|0 )
        txt @ 0= if s" " me text! then
        txt @ lcount ;
trait;

\ -- Label ---------------------------------------------------------------------

variable editing
|| 0 value original

class: %label
    %ui-box derive
    is-a %textual
    prop clr <save
    prop editable <save
    prop clear-on-edit <save
    template { fnt@ fnt ! $FFFFFFFF clr ! editable on }

    :: on-clone
        me text@ *lstring txt ! _update-box ;

    : editing-me?  editing @ focused me = and ;

    : _draw-text
        txt @ ?dup if fnt @ fnt! lcount print then
        editing-me? if
            me text@ nip 8 * 0 +at '_' glyph
        then ;

    :: _draw
        editing-me? if red else clr @ rgba8 then
        _draw-text ;

    :: _mousedown ( btn - )
        lmb = -exit
        editable @ -exit
        me focus
        editing on
        original free drop
        me text@ *lstring to original
        clear-on-edit @ if
            s" " me text!
        then
    ;

    : _revert
        original lcount me text!
        original free drop
        0 to original ;

    : _stop-editing
        editing off
        esc-quits off ;

    :: _process
        repl-game-active @ not if esc-quits on then
        editing-me? -exit
        <esc> pressed? if
            _stop-editing
            _revert
        then ;

    :: _keychar ( key - )
        editing-me? not if drop exit then
        dup <enter> = if
            drop _stop-editing
            exit
        then
        dup <bksp> = if
            drop txt @ lcount 1 - 0 max me text!
            exit
        then
        drop the-char me add-char ;

class;

: *label ( a len - label )
    %label add { me text! you { rgba8@ } clr ! me } ;

%label :: click-box@ ( - x1 y1 x2 y2 )
    abspos w @ 16. max h @ box ;

trait: %syncable-value
    prop ra :addr <readonly \ remote address
    prop val <save
    prop val-type <save
    prop was-editing <readonly

    :: sync ( - )
        ra @ -exit
        editing-me? not was-editing @ and if
            val @ ra @ !
        then
        editing-me? not if
            ra @ @ val !
        then
        editing-me? was-editing ! ;

trait;

\ -- Number ---------------------------------------------------------------------

class: %numberfield
    %label derive
    is-a %syncable-value
    template { TYPE_INT val-type !   clear-on-edit on }

    : val>str ( - a len )
        val-type @ TYPE_INT = if val @ f" %n" exit then
        val-type @ TYPE_FIXED = if val @ f" %p" exit then
        -1 abort" invalid val-type" ;

    :: _draw 
        editing-me? not if val>str me text! then
        label:_draw ;

    :: _process
        editing-me?
        label:_process 
        txt @ 0<> and if 
            me text@ s" -" s= not if
                sp@ >r val @
                me text@ ['] evaluate catch if 
                    2drop 
                else 
                    val-type @ TYPE_FIXED = if
                        me text@ s" ." strin? not if >p then
                    then
                then
                val !
                r> sp! 
            then
        then
        me sync ;

class;

: *int  %numberfield add { val ! TYPE_INT val-type ! me } ;
: *fixed  %numberfield add { val ! TYPE_FIXED val-type ! me } ;

\ -- String Field --------------------------------------------------------------

trait: %syncable-string
    prop ra :addr <readonly
    prop str-type <readonly       \ TYPE_CSTRING or TYPE_LSTRING
    prop was-editing <readonly

    :: sync ( - )
        ra @ -exit
        editing-me? not was-editing @ and if
            str-type @ TYPE_CSTRING = if
                me text@ ra @ place
            else
                ra @ @ free drop
                me text@ *lstring ra @ !
            then
        then
        editing-me? not if
            str-type @ TYPE_CSTRING = if
                ra @ count me text!
            else
                ra @ @ ?dup if lcount else s" " then me text!
            then
        then
        editing-me? was-editing ! ;
trait;

class: %stringfield
    %label derive
    is-a %syncable-string
    template { clear-on-edit off }

    :: _draw
        editing-me? not if me sync then
        label:_draw ;

    :: _process
        label:_process
        me sync ;
class;

: *stringfield ( str-type - stringfield )
    %stringfield add { str-type ! s" " me text! me } ;

\ -- Forth elements -----------------------------------------------------------

class: %command
    %label derive
    prop obj :ref %object

    || 2. constant m

    :: click-box@ ( - x1 y1 x2 y2 )
        abspos m m 2- w 2@ m m 2 2 2* 2+ box ;

    :: _draw
        m >i negate dup +at
        white w 2@ m m 2 2 2* 2+ rectf 
        black w 2@ m m 2 2 2* 2+ rect 
        m m 2>i +at
        black _draw-text ;

    :: _mousedown ( btn - )
        lmb = -exit
        bolted? not shift? not and ?exit
        obj @ ?dup if as> then
        me text@ evaluate ;
class;

: *command ( a len - command )
    %command add { me text! me } ;

class: %repl
    %label derive
    prop obj :ref %object

    template { 150. 10. w 2! }

    || redef 2. constant rm

    :: click-box@ ( - x1 y1 x2 y2 )
        abspos m m 2- w 2@ m m 2 2 2* 2+ box ;

    :: _draw
        m >i negate dup +at
        black see-thru w 2@ m m 2 2 2* 2+ rectf
        grey w 2@ m m 2 2 2* 2+ rect
        m m 2>i +at
        yellow _draw-text ;

    : _evaluate
        obj @ ?dup if
            { me text@ evaluate }
        else
            me text@ evaluate
        then ;

    :: _keychar ( key - )
        editing-me? not if drop exit then
        dup <enter> = if
            drop _stop-editing ['] _evaluate catch .throw
            s" " me text! 
            exit
        then
        dup <bksp> = if
            drop txt @ lcount 1 - 0 max me text!
            exit
        then
        drop the-char me add-char ;

    :: text! ( a len - )
        w 2@ 2>r
        textual:text!
        2r> w 2! ;
class;

: *repl ( w - repl )
    %repl add { >p w ! s" " me text! me } ;

\ -- Menu Item ----------------------------------------------------------------

class: %menu-item
    %label derive
    prop xt :addr <readonly  \ XT to execute on click
    prop obj :ref %object <readonly
    template { editable off }

    :: _enter  valof white clr ! ;
    :: _leave  valof cyan clr ! ;

    : trigger-menu-item ( menu-item - )
        xt @ 
        obj @ ?dup if as> then
        ?execute ;

    :: _mousedown ( btn - )
        lmb = -exit 
        me trigger-menu-item ;

class;

0 %menu-item :construct ( - )
    ui-box:construct   valof cyan clr ! ;

\ -- Menu ---------------------------------------------------------------------

c: %menu %panel ;

: *menu ( - menu )
    %menu add { 4 4 at me 50. 8. w 2! } ;

: *menu-item ( object|0 xt text len - menu-item )
    9. h +!        \ grow menu height 
    %menu-item add { 
        me text! xt ! obj ! +bolted 
        w @ 8. + you >w @ max you >w ! \ expand width to fit
    me } 
    0 9 +at ;

: option ( object|0 xt text len - )
    *menu-item drop ;

\ -- HUD -----------------------------------------------------------------------

class: %hud
    %element derive
    :: forth@  s" me to hud" ;
class;

%hud dmake value hud

: draw-hud
    hud -exit
    0 0 at 
    hud draw ;

\ -- Global Context Menu State ------------------------------------------------

0 value context-menu   \ current open context menu, or 0

: close-context-menu ( - )
    context-menu ?dup if unload then
    0 to context-menu ;

: corral 
    x 2@ 0 0 2max x 2!
    winw zoom @ / winh zoom @ / 
    2>p w 2@ 2-`` x 2@`` 2min x 2! ;

: open-context-menu ( element - )
    close-context-menu
    dup mouse me from-element    
    hud {
        *menu to context-menu
        context-menu swap _context-menu
        context-menu #children 0= if close-context-menu exit then
        context-menu ?dup if { corral } then
    } ;

%menu-item :: _mousedown ( btn - )
    menu-item:_mousedown  close-context-menu  
    0 to hovered ;

\ -- Mouse ---------------------------------------------------------------------

variable drag-btn
variable dragging
variable drag-moved  \ true if mouse actually moved during drag

: in-me?  2>p 2dup me click-box@ overlap? ;

defer _topmost-element
[:
    dup active? not if drop exit then
    [: {
        me active? mouse in-me? and if drop me then
        me opened? if
            me _topmost-element
        then
    } ;] swap each
;] is _topmost-element

: topmost-element ( - element|0 )
    0 me _topmost-element ;

\ Same as topmost-element but skips root and desktops (for cycling)
|| 0 value top-selectable

defer _topmost-selectable
[:
    dup active? not if drop exit then
    [: {
        me active? mouse in-me? and parent @ and me %desktop is? not and if
            me to top-selectable
        then
        me opened? if me _topmost-selectable then
    } ;] swap each
;] is _topmost-selectable

: topmost-selectable ( - element|0 )
    0 to top-selectable
    me _topmost-selectable
    top-selectable ;

\ Find element below 'skip' under mouse (for cycling selection)
\ "Below" = earlier in traversal (visually underneath)
\ Returns 0 if skip not found or nothing below it
|| 0 value skip-element
|| 0 value found-skip
|| 0 value below-element

defer _element-below
[:  ( element - )
    dup active? not if drop exit then
    [: {
        me active? mouse in-me? and parent @ and me %desktop is? not and if
            me skip-element = if
                true to found-skip
            else
                found-skip not if me to below-element then
            then
        then
        me opened? if me _element-below then
    } ;] swap each
;] is _element-below

: element-below ( skip-elem root - elem|0 )
    swap to skip-element
    false to found-skip
    0 to below-element
    _element-below
    below-element ;

: hover ( element - )
    dup hovered = if drop exit then
    hovered ?dup if _leave then
    to hovered
    hovered ?dup if _enter then ;

: target-element ( - element|0 )
    \ Returns selected element if under mouse, otherwise hovered element
    selection #items if
        mouse this { in-me? } if this exit then
    then
    hovered ;

|| 0 value click-candidate  \ element that might receive a cycle-click
|| 0 value last-click-x
|| 0 value last-click-y

: mouse-moved-since-click? ( - flag )
    mouse last-click-y <> swap last-click-x <> or ;

: record-click-position ( - )
    mouse to last-click-y to last-click-x ;

: preview-selection ( - element|0 )
    \ In designing mode, preview what would be selected on click
    designing? not if hovered exit then
    \ If mouse moved, would select topmost
    mouse-moved-since-click? if hovered exit then
    selection #items 0= if hovered exit then
    \ If selected element is under mouse and mouse hasn't moved, show cycle target
    mouse this { in-me? } if
        this me element-below ?dup if exit then
        topmost-selectable exit
    then
    hovered ;

: begin-drag ( btn -- )
    drag-btn ! dragging on drag-moved off ;

: end-drag ( -- )
    dragging off drag-moved off ;

: handle-rmb
    rmb pressed? if
        target-element ?dup if rmb swap _mousedown then
    then ;

: cycle-select ( - )
    \ Cycle to element below the current selection
    selection #items 0= if exit then
    this me element-below ?dup if
        select
    else
        topmost-selectable ?dup if select then
    then ;

: handle-lmb
    <space> held? ?exit
    lmb pressed? if
        0 to click-candidate
        hovered if
            \ Bolted elements always "use" on click
            \ In using mode, all elements "use" on click
            focused if
                hovered focused <> if unfocus then
            then
            hovered { bolted? } using? or if
                lmb hovered _mousedown
            else
                \ Designing mode + not bolted = drag behavior
                lmb hovered _mousedown
                hovered -exit
                \ Only allow cycling if mouse hasn't moved since last click
                mouse-moved-since-click? not if
                    selection #items if
                        mouse this { in-me? } if
                            \ Selected element is under mouse - set up cycling
                            this to click-candidate
                            this { bolted? } not if lmb begin-drag then
                            record-click-position
                            exit
                        then
                    then
                then
                \ Normal selection (mouse moved or first click)
                hovered ctrl? if +select else select then
                selection #items if
                    lmb begin-drag
                then
                record-click-position
            then
        else
            selection vacate
        then
    then
    drag-btn @ letgo? if
        \ If released without actual movement and had a cycle candidate, cycle
        drag-moved @ not click-candidate and if
            cycle-select
        then
        end-drag
        0 to click-candidate
    then ;

: handle-context-menu
    designing? -exit
    rmb pressed? shift? not and if
        target-element ?dup if
            open-context-menu
        else
            close-context-menu
        then
    then
    \ close on LMB click outside menu
    lmb pressed? <space> pressed? not and if
        context-menu if
            hovered context-menu <>
            hovered context-menu contains? not and
            if close-context-menu then
        then
    then ;

: do-drag
    dragging @ -exit
    mickey 2>p                          \ get mouse delta
    2dup or if drag-moved on then       \ track if any movement
    [: { 2dup x 2+! } ;] selection each \ apply to all selected
    2drop ;

: handle-keys
    <del> pressed? if
        ['] unload selection each
        selection vacate
    then ;

: handle-mode-toggle
    <tab> pressed? if toggle-mode then ;

: handle-focused-keys
    focused -exit
    ALLEGRO_EVENT_KEY_DOWN happened? if
        the-key focused _keydown
    then
    ALLEGRO_EVENT_KEY_CHAR happened? if
        the-key focused _keychar
    then ;

: gui-input ( element - )
    as>
    handle-lmb
    handle-rmb
    do-drag
    topmost-element hover
    handle-context-menu
    handle-mode-toggle
    begin event? while
        handle-focused-keys
    repeat
    handle-keys
;

: process-gui ( element - )
    dup gui-input dup process sweep ;

: click-box  me click-box@ 2over atp 2swap 2- rect ;

: gui-overlay ( - )
    [: { light-green 0.5 ppena! click-box } ;] selection each
    designing? if
        \ In designing mode, preview what would be selected on click
        preview-selection ?dup if { bolted? if yellow else green then click-box } then
    else
        \ In using mode, show hover
        hovered ?dup if { bolted? if yellow else green then click-box } then
    then
    focused ?dup if { cyan click-box } then ;

\ -- Inspection ----------------------------------------------------------------

require %idir%/inspect.vfx

%desktop :: _process
    desktop:_process
    rmb pressed? if
        shift? if
            target-element ?dup if toggle-inspector then
        then
        alt? if
            target-element ?dup if unload then
        then
    then ;

\ -- Desktop-specific HUDs -----------------------------------------------------
    
class: %desktop-hud
    %element derive
    :: active? parent @ ?dup if active? else false then ;
    :: _process
        parent @ ?dup if
            dup >x 2@ 2negate x 2!  \ stay fixed on screen
            me swap push            \ stay on top
        then ;
class;

\ -- Default context menu ------------------------------------------------------

: detach,
    you { bolted? } ?exit
    you [: 
        abspos me dup >root push x 2! 
    ;] s" Detach" option ;

: attach,
    selection #items if
        you >parent @ this = ?exit
    else
        exit
    then
    you [: 
        selection #items -exit 
        this me = ?exit
        this { you relpos x 2! }
        this me push 
    ;] 
    s" Attach" option ;

: delete,
    you { bolted? } ?exit     
    you [: me unload ;] s" Delete" option ;

: clone,
    \ you { bolted? } ?exit 
    you [: 
        me deep-clone dup me insert-over 
        { 
            5. 5. x 2+! 
            selection vacate
            me selection push
            -bolted
            me to hovered
        } 
    ;] 
    s" Clone" option ;

: front,
    you >parent @ -exit
    you { bolted? parent @ >highest @ me = or } ?exit 
    you [:
        me dup >parent @ push
    ;]
    s" Front" option ;

: back,
    you >parent @ -exit
    you { bolted? parent @ >lowest @ me = or } ?exit 
    you [:
        me dup >parent @ unshift
    ;]
    s" Back" option ;

: bolt,
    you [:
        bolted? if -bolted else +bolted then
    ;] 
    you { bolted? } if s" Unbolt" else s" Bolt" then option ;

: sticky,
    you { bolted? } ?exit
    hud -exit
    you >parent @ hud = if
        you [: abspos me dup >root push x 2! ;] s" Unsticky" option
    else
        you [: abspos me hud push x 2! ;] s" Sticky" option
    then ;

: clear,
    you #children -exit
    you [: ['] unload me each ;] 
    s" Clear" option ;

: save-tree-dialog ( element - )
    0 z" Save JSON" z" *.json" ALLEGRO_FILECHOOSER_SAVE file-dialog
    ?dup if 
        -ext f" %s.json" save-tree
    else 
        drop
    then ;

: save,
    you [: me save-tree-dialog ;] s" Save" option ;

: common-options,
    clone,
    attach,
    save,
    \ detach,
    front,
    back,
    bolt,
    sticky,
    clear,
    delete, ;

%element :: _context-menu ( menu - )
    as> common-options, ;

%menu-item :: _context-menu ( menu - ) drop ;
%menu :: _context-menu ( menu - ) drop ;