\ =============================================================================
\ GUI
\ =============================================================================

\ -- Dependencies --------------------------------------------------------------

REQUIRE %vfxland5%/forge/lib/dltree.vfx
REQUIRE %vfxland5%/lib/mouse.vfx
REQUIRE %idir%/shapes.vfx
REQUIRE %idir%/colors.vfx
REQUIRE %idir%/element.vfx

\ -- Desktop -------------------------------------------------------------------

class: %desktop
    %element derive
    prop clr <save
    template { valof dark-grey clr ! }

    :: click-box@ 0 0 winw winh 2>p ;
    :: _process <space> held? lmb? and if mickey 2>p x 2+! then ;
    :: _draw 0 0 at clr @ rgba8 winw winh 2>p rectf ;
class;

\ -- UI Box --------------------------------------------------------------------

class: %ui-box
    %element derive

    prop w :fixed <save
    prop h :fixed <save

    template { 100. 100. w 2! } 

    EC_MAX_SIZE nprop ec  template { ec clear-ec }

    :: click-box@ ( - x1 y1 x2 y2 ) abspos w 2@ box ;

class;

0 %ui-box :construct ( - )
    at@p x 2!   ec ecp! in-heap ;

\ -- Selection -----------------------------------------------------------------

: +select  ( element - ) selection ?push ;
: select   ( element - ) selection vacate selection push ;

\ -- Panel ---------------------------------------------------------------------

class: %panel
    %ui-box derive
    prop clr <save
    template { black see-thru rgba8@ clr ! }
    :: _draw  clr @ rgba8 w 2@ rectf ;
class;

\ -- Textual Trait -------------------------------------------------------------

trait: %textual
    prop txt :lstring <save  \ heap-allocated lstring
    prop fnt :addr 
    prop w :fixed
    prop h :fixed
    prop tx :fixed  \ text offset
    prop ty :fixed

    : _update-box  
        fnt @ fnt!  txt @ lcount textbox 2>p w 2! 2>p tx 2! ;

    :: text! ( a n - ) 
        dup 0< if 2drop exit then
        txt @ >r 
        *lstring txt !
        _update-box 
        r> free drop \ ignore ior 
    ;

    :: add-char ( n - )
        txt @ lcount cell+ -4 u+ 1 + resize throw txt !
        ( n ) pad c!  pad 1 txt @ lappend 
        _update-box ;

    :: text@ ( - a len | 0 0 )
        txt @ dup if lcount else 0 then ;
trait;

\ -- Label ---------------------------------------------------------------------

variable editing
0 value focus
|| 0 value original

class: %label
    %ui-box derive
    is-a %textual
    prop clr <save
    prop editable <save
    prop clear-on-edit <save
    template { fnt@ fnt ! $FFFFFFFF clr ! editable on }

    :: on-clone
        me text@ *lstring txt ! _update-box ;

    : editing-me?  editing @   focus me = and ;

    : _draw-text
        txt @ ?dup if fnt @ fnt! lcount print then 
        editing-me? if 
            me text@ nip 8 * 0 +at '_' glyph 
        then ;

    :: _draw  
        editing-me? if red else clr @ rgba8 then
        _draw-text ;        

    :: _mousedown ( btn - )
        lmb = -exit
        editable @ -exit
        me to focus
        editing on 
        original free drop
        txt @ lcount *lstring to original 
        clear-on-edit @ if
            s" " me text! 
        then 
    ;

    : _revert
        original lcount me text!
        original free drop ;

    :: _process
        \ TODO: use ACT> (factor out a %statemachine trait)
        repl-game-active @ not if esc-quits on then
        editing-me? -exit
        <esc> pressed? if   \ doesn't work if put in the event handler
            editing off
            _revert
            esc-quits off
            exit
        then
        event? -exit
        ALLEGRO_EVENT_KEY_CHAR happened? if 
            the-key <enter> = if
                editing off
                me text@ nip 0= if _revert then
                exit
            then
            \ the-key <enter> = if
            \     10 me add-char
            \     exit
            \ then
            the-key <bksp> = if
                txt @ lcount 1 - 0 max me text!
                exit
            then
            txt @ if
                the-char me add-char
            then
        then ;

class;

: *label ( a len - label )
    %label add { me text! you { rgba8@ } clr ! me } ;

%label :: click-box@ ( - x1 y1 x2 y2 )
    abspos w @ 16. max h @ box ;

trait: %syncable-value
    prop ra :addr <readonly \ remote address
    prop val <save
    prop val-type <save
    prop was-editing <readonly

    :: sync ( - )
        ra @ -exit
        editing-me? not was-editing @ and if
            val @ ra @ !
        then
        editing-me? not if
            ra @ @ val !
        then
        editing-me? was-editing ! ;

trait;

\ -- Number ---------------------------------------------------------------------

class: %numberfield
    %label derive
    is-a %syncable-value
    template { TYPE_INT val-type !   clear-on-edit on }

    : val>str ( - a len )
        val-type @ TYPE_INT = if val @ f" %n" exit then
        val-type @ TYPE_FIXED = if val @ f" %p" exit then
        -1 abort" invalid val-type" ;

    :: _draw 
        editing-me? not if val>str me text! then
        label:_draw ;

    :: _process
        editing-me?
        label:_process 
        txt @ 0<> and if 
            me text@ s" -" s= not if
                sp@ >r val @
                me text@ ['] evaluate catch if 
                    2drop 
                else 
                    val-type @ TYPE_FIXED = if
                        me text@ s" ." strin? not if >p then
                    then
                then
                val !
                r> sp! 
            then
        then
        me sync ;

class;

: *int  %numberfield add { val ! TYPE_INT val-type ! me } ;
: *fixed  %numberfield add { val ! TYPE_FIXED val-type ! me } ;

\ -- String Field --------------------------------------------------------------

trait: %syncable-string
    prop ra :addr <readonly
    prop str-type <readonly       \ TYPE_CSTRING or TYPE_LSTRING
    prop was-editing <readonly

    :: sync ( - )
        ra @ -exit
        editing-me? not was-editing @ and if
            str-type @ TYPE_CSTRING = if
                me text@ ra @ place
            else
                ra @ @ free drop
                me text@ *lstring ra @ !
            then
        then
        editing-me? not if
            str-type @ TYPE_CSTRING = if
                ra @ count me text!
            else
                ra @ @ ?dup if lcount else s" " then me text!
            then
        then
        editing-me? was-editing ! ;
trait;

class: %stringfield
    %label derive
    is-a %syncable-string
    template { clear-on-edit off }

    :: _draw
        editing-me? not if me sync then
        label:_draw ;

    :: _process
        label:_process
        me sync ;
class;

: *stringfield ( str-type - stringfield )
    %stringfield add { str-type ! s" " me text! me } ;

\ -- Forth elements -----------------------------------------------------------

class: %command
    %label derive
    prop obj :ref %object

    || 2. constant m

    :: click-box@ ( - x1 y1 x2 y2 )
        abspos m m 2- w 2@ m m 2 2 2* 2+ box ;

    :: _draw
        m >i negate dup +at
        white w 2@ m m 2 2 2* 2+ rectf 
        black w 2@ m m 2 2 2* 2+ rect 
        m m 2>i +at
        black _draw-text ;

    :: _mousedown ( btn - )
        lmb = -exit
        bolted? not shift? not and ?exit
        obj @ ?dup if as> then
        me text@ evaluate ;
class;

: *command ( a len - command )
    %command add { me text! me } ;

class: %repl
    %label derive
    prop obj :ref %object

    template { 150. 10. w 2! }

    || redef 2. constant rm

    :: click-box@ ( - x1 y1 x2 y2 )
        abspos m m 2- w 2@ m m 2 2 2* 2+ box ;

    :: _draw
        m >i negate dup +at
        black see-thru w 2@ m m 2 2 2* 2+ rectf 
        grey w 2@ m m 2 2 2* 2+ rect 
        m m 2>i +at
        yellow _draw-text ;

    :: _process
        editing-me? >r
        w 2@ 2>r
        label:_process
        2r> w 2!
        r> editing-me? not and if
            obj @ ?dup if 
                rot { evaluate } 
            else 
                me text@ evaluate
            then
            s" " me text!
        then ;

    :: text! ( a len - )
        w 2@ 2>r
        textual:text!
        2r> w 2! ;
class;

: *repl ( w - repl )
    %repl add { >p w ! s" " me text! me } ;

\ -- Menu Item ----------------------------------------------------------------

class: %menu-item
    %label derive
    prop xt :addr <readonly  \ XT to execute on click
    prop obj :ref %object <readonly
    template { editable off }

    :: _enter  valof white clr ! ;
    :: _leave  valof cyan clr ! ;

    : trigger-menu-item ( menu-item - )
        xt @ 
        obj @ ?dup if as> then
        ?execute ;

    :: _mousedown ( btn - )
        lmb = -exit 
        me trigger-menu-item ;

class;

0 %menu-item :construct ( - )
    ui-box:construct   valof cyan clr ! ;

\ -- Menu ---------------------------------------------------------------------

c: %menu %panel ;

: *menu ( - menu )
    %menu add { 4 4 at me 50. 8. w 2! } ;

: *menu-item ( object|0 xt text len - menu-item )
    9. h +!        \ grow menu height 
    %menu-item add { 
        me text! xt ! obj ! +bolted 
        w @ 8. + you >w @ max you >w ! \ expand width to fit
    me } 
    0 9 +at ;

: option ( object|0 xt text len - )
    *menu-item drop ;

\ -- Global Context Menu State ------------------------------------------------

0 value context-menu   \ current open context menu, or 0

: close-context-menu ( - )
    context-menu ?dup if unload then
    0 to context-menu ;

: open-context-menu ( element - )
    close-context-menu
    dup mouse from-root
    *menu to context-menu
    context-menu swap _context-menu
    context-menu #children 0= if close-context-menu then ;

%menu-item :: _mousedown ( btn - )
    menu-item:_mousedown  close-context-menu  
    0 to hovered ;

\ -- Mouse ---------------------------------------------------------------------

variable drag-btn
variable dragging

|| : in?  2>p 2dup me click-box@ overlap? ;

defer _topmost-element
[: 
    [: { 
        mouse in? if drop me then
        me _topmost-element 
    } ;] swap each
;] is _topmost-element

: topmost-element ( - element|0 )
    0 me _topmost-element ;

: hover ( element - )
    dup hovered = if drop exit then
    hovered ?dup if _leave then
    to hovered
    hovered ?dup if _enter then ;

: begin-drag ( btn -- )
    drag-btn ! dragging on ;

: end-drag ( -- )
    dragging off ;

: handle-lmb
    <space> held? ?exit
    lmb pressed? if
        hovered if
            lmb hovered _mousedown
            hovered -exit
            hovered { bolted? } not if
                hovered ctrl? if +select else select then
                selection #items if
                    lmb begin-drag
                then
            then
        else
            selection vacate
        then
    then
    \ lmb letgo? if
    \     hovered if
    \         lmb hovered _mouseup
    \     then
    \ then ;
    drag-btn @ letgo? if
        end-drag
    then ;

: handle-context-menu
    rmb pressed? 
    shift? not and if
        hovered if
            hovered open-context-menu
        else
            close-context-menu
        then
    then
    \ close on LMB click outside menu
    lmb pressed? 
    <space> pressed? not and if
        context-menu if
            hovered context-menu <>
            hovered context-menu contains? not and
            if close-context-menu then
        then
    then ;

: do-drag 
    dragging @ -exit
    mickey 2>p                          \ get mouse delta
    [: { 2dup x 2+! } ;] selection each \ apply to all selected
    2drop ;

: handle-keys
    <del> pressed? if 
        ['] unload selection each
        selection vacate
    then ;

: gui-input ( element - )
    as> 
    handle-lmb
    do-drag
    topmost-element hover 
    handle-context-menu
    handle-keys
;

: click-box  me click-box@ 2over atp 2swap 2- rect ;

: gui-overlay ( - )
    [: { light-green 0.5 ppena! click-box } ;] selection each 
    hovered ?dup if { bolted? if green else yellow then click-box } then ;

\ -- Inspection ----------------------------------------------------------------

require %idir%/inspect.vfx

%desktop :: _process
    desktop:_process
    rmb pressed? if
        shift? if
            hovered ?dup if toggle-inspector then
        then
        alt? if
            hovered ?dup if unload then
        then
    then ;

\ -- Default context menu ------------------------------------------------------

: detach,
    you { bolted? } ?exit
    you [: 
        abspos me dup >root push x 2! 
    ;] s" Detach" option ;

: attach,
    selection #items if
        you >parent @ selection peek = ?exit
    else
        exit
    then
    you [: 
        selection #items -exit 
        5 5 selection peek >x 2!
        selection peek me push 
    ;] 
    s" Attach" option ;

: delete,
    you { bolted? } ?exit     
    you [: me unload ;] s" Delete" option ;

: clone,
    you { bolted? } ?exit 
    you [: 
        me deep-clone dup me insert-over 
        { 
            5. 5. x 2+! 
            selection vacate
            me selection push
            me to hovered
        } 
    ;] 
    s" Clone" option ;

: front,
    you >parent @ -exit
    you { bolted? parent @ >highest @ me = or } ?exit 
    you [:
        me dup >parent @ push
    ;]
    s" Front" option ;

: back,
    you >parent @ -exit
    you { bolted? parent @ >lowest @ me = or } ?exit 
    you [:
        me dup >parent @ unshift
    ;]
    s" Back" option ;

: bolt,
    you [:
        bolted? if -bolted else +bolted then
    ;] 
    you { bolted? } if s" Unbolt" else s" Bolt" then option ;

: common-options,
    clone,
    attach,
    detach,
    front,
    back,
    bolt,
    delete, ;

%element :: _context-menu ( menu - )
    as> common-options, ;

%menu-item :: _context-menu ( menu - ) drop ;
%menu :: _context-menu ( menu - ) drop ;