\ =============================================================================
\ GUI
\ =============================================================================

\ -- Dependencies --------------------------------------------------------------

REQUIRE %vfxland5%/forge/lib/dltree.vfx
REQUIRE %vfxland5%/lib/mouse.vfx
REQUIRE %idir%/shapes.vfx
REQUIRE %idir%/colors.vfx

0 value hovered
1024 %addr stack selection

\ -- Context -------------------------------------------------------------------

ECONTEXT gui-ec

\ -- Base Trait ----------------------------------------------------------------

trait: %_element
    is-a %dltree
    is-a %drawable
    is-a %unloadable
    prop x :fixed <save
    prop y :fixed <save
    prop flags
    :: click-box@ ( - x1. y1. x2. y2. ) $DEADBEEF dup dup dup ;
    \ :: _click ( n - ) drop ;
    :: _enter ( - ) ;
    :: _leave ( - ) ;
    :: _mousedown ( btn - ) drop ;  \ lbm , rmb , or mmb
    \ :: _mouseup ( btn - ) drop ;
    \ :: _mousemove ( - ) ;
    :: _process ( - ) ;
    :: _draw ( - ) ;
    :: delete ( - ) stub ;
    :: draggable? ( - flag ) true ;
    :: _context-menu ( menu - ) drop ;   \ override to add items / customize the menu
    :: on-clone ( - ) ;
trait;

\ -- Helpers -------------------------------------------------------------------

: +unloaded  1 flags or! ;
: unloaded?  flags @ 1 and 0<> ;
: +bolted    2 flags or! ;
: bolted?    flags @ 2 and 0<> ;

: abspos  x 2@ me begin >parent @ ?dup while { x 2@ 2+ me } repeat ;
: at-me  abspos atp ;
: box  2over 2+ ;
: ?push  2dup contains? if 2drop exit then push ;
: see-thru   0.5 ppena! ;
\ : click-dims  me click-box@ 2swap 2- ;

: >root ( element - root )
    begin dup >parent @ ?dup while nip repeat ;

: from-root ( element x y - )
    rot >root >x 2@ 2>i 2- at ;

: relpos ( element - x. y. ) 
    { abspos } abspos 2swap 2- ;

\ -- Element Class -------------------------------------------------------------

class: %element
    is-a %_element
    template { gui-ec ecp! in-heap }
class;

0 %element :construct ( - )
    at@p x 2!  gui-ec ecp! in-heap ;

: delete-element ( element - )
    dup hovered = if 0 to hovered then
    dup { ['] delete me each }   \ recursively delete children
    dup selection contains? if dup selection remove then
    dup dlremove free drop ;

%element :: delete
    me delete-element ;

\ -- Element Methods -----------------------------------------------------------

%element :: unload ( - )
    +unloaded ;

defer _sweep
: sweep ( iterable - )
    [: dup _sweep { unloaded? if me delete then } ;] swap each ;
['] sweep is _sweep

%element :: vacate
    ['] unload me each  me sweep ;

%element :: push
    dup %element is? not abort" ELEMENT:PUSH : Source is not an element."
    dltree:push ;

%element :: insert-under
    dup %element is? not abort" ELEMENT:INSERT-UNDER : Source is not an element."
    dltree:insert-under ;

%element :: insert-over
    dup %element is? not abort" ELEMENT:INSERT-OVER : Source is not an element."
    dltree:insert-over ;

%element :: unshift
    dup %element is? not abort" ELEMENT:UNSHIFT : Source is not an element."
    dltree:unshift ;

defer __process
: process ( element - )
    dup _process ['] __process swap each ;
['] process is __process

%element :: draw
    \ TODO: fix this workaround
    vga-8x8 fnt!

    at-me  me _draw ['] draw me each ;

\ -- Clone ---------------------------------------------------------------------

: clone ( element - element' )
    as> \ scope into object. establishes EC
        cla @ make {     \ create new instance of same class
            you me dup sizeof move  \ copy data
            0 dup dup dup dup
            parent ! prev ! next ! lowest ! highest !
            0 item-count !
            me on-clone
        me } ;

defer _deep-clone
: deep-clone ( element - element' )
    dup clone swap
    [: _deep-clone over push ;] swap each ;
' deep-clone is _deep-clone

\ -- Desktop -------------------------------------------------------------------

class: %desktop
    %element derive

    :: click-box@ 0 0 winw winh 2>p ;
    :: _process <space> held? lmb? and if mickey 2>p x 2+! then ;
    :: _draw 0 0 at dark-grey winw winh 2>p rectf ;
class;

\ -- UI Box --------------------------------------------------------------------

class: %ui-box
    %element derive

    prop w :fixed <save
    prop h :fixed <save
    template { 100. 100. w 2! } 

    EC_MAX_SIZE nprop ec  template { ec clear-ec }

    :: click-box@ ( - x1 y1 x2 y2 ) abspos w 2@ box ;
class;

0 %ui-box :construct ( - )
    at@p x 2!   ec ecp! in-heap ;

\ -- Selection -----------------------------------------------------------------

: +select  ( element - ) selection ?push ;
: select   ( element - ) selection vacate selection push ;

\ -- Panel ---------------------------------------------------------------------

class: %panel
    %ui-box derive
    prop clr <save
    template { black see-thru rgba8@ clr ! }
    :: _draw  clr @ rgba8 w 2@ rectf ;
class;

\ -- Textual Trait -------------------------------------------------------------

redef : *lstring ( a n - a' )
    dup cell+ allocate throw >r r@ lplace r> ;

trait: %textual
    prop txt :lstring <save  \ heap-allocated lstring
    prop fnt :addr 
    prop w :fixed
    prop h :fixed
    prop tx :fixed  \ text offset
    prop ty :fixed

    : _update-box  
        fnt @ fnt!  txt @ lcount textbox 2>p w 2! 2>p tx 2! ;

    :: text! ( a n - ) 
        dup 0< if 2drop exit then
        txt @ >r 
        *lstring txt !
        _update-box 
        r> free drop \ ignore ior 
    ;

    :: add-char ( n - )
        txt @ lcount cell+ -4 u+ 1 + resize throw txt !
        ( n ) pad c!  pad 1 txt @ lappend 
        _update-box ;

    :: text@ ( - a len | 0 0 )
        txt @ dup if lcount else 0 then ;
trait;

\ -- Label ---------------------------------------------------------------------

variable editing
0 value focus
|| 0 value original

class: %label
    %ui-box derive
    is-a %textual
    prop clr <save
    prop editable <save
    prop clear-on-edit <save
    template { fnt@ fnt ! $FFFFFFFF clr ! editable on }

    :: on-clone
        me text@ *lstring txt ! _update-box ;

    : editing-me?  editing @   focus me = and ;

    :: _draw  
        editing-me? if red else clr @ rgba8 then
        txt @ ?dup if fnt @ fnt! lcount print then ;

    :: _mousedown ( btn - )
        lmb = -exit
        editable @ -exit
        me to focus
        editing on 
        original free drop
        txt @ lcount *lstring to original 
        clear-on-edit @ if
            s" " me text! 
        then 
    ;

    : _revert
        original lcount me text!
        original free drop ;

    :: _process
        \ TODO: use ACT> (factor out a %statemachine trait)
        repl-game-active @ not if esc-quits on then
        editing-me? -exit
        <esc> pressed? if   \ doesn't work if put in the event handler
            editing off
            _revert
            esc-quits off
            exit
        then
        event? -exit
        ALLEGRO_EVENT_KEY_CHAR happened? if 
            the-key <enter> = if
                editing off
                me text@ nip 0= if _revert then
                exit
            then
            \ the-key <enter> = if
            \     10 me add-char
            \     exit
            \ then
            the-key <bksp> = if
                txt @ lcount 1 - 0 max me text!
                exit
            then
            txt @ if
                the-char me add-char
            then
        then ;

class;

: *label ( a len - label )
    %label add { me text! me } ;

%label :: click-box@ ( - x1 y1 x2 y2 )
    abspos w @ 16. max h @ box ;

trait: %syncable-value
    prop ra :addr \ remote address
    prop val <save
    prop val-type <save
    prop was-editing

    :: sync ( - )
        ra @ -exit
        editing-me? not was-editing @ and if
            val @ ra @ !
        then
        editing-me? not if
            ra @ @ val !
        then
        editing-me? was-editing ! ;

trait;

\ -- Number ---------------------------------------------------------------------

class: %number
    %label derive
    is-a %syncable-value
    template { TYPE_INT val-type !   clear-on-edit on }

    : val>str ( - a len )
        val-type @ TYPE_INT = if val @ f" %n" exit then
        val-type @ TYPE_FIXED = if val @ f" %p" exit then
        -1 abort" invalid val-type" ;

    :: _draw 
        editing-me? not if val>str me text! then
        label:_draw ;

    :: _process
        editing-me?
        label:_process 
        txt @ 0<> and if 
            me text@ s" -" s= not if
                sp@ >r val @
                me text@ ['] evaluate catch if 
                    2drop 
                else 
                    val-type @ TYPE_FIXED = if
                        me text@ s" ." strin? not if >p then
                    then
                then
                val !
                r> sp! 
            then
        then
        me sync ;

class;

: *int  %number add { val ! TYPE_INT val-type ! me } ;
: *fixed  %number add { val ! TYPE_FIXED val-type ! me } ;

\ -- Menu Item ----------------------------------------------------------------

class: %menu-item
    %label derive
    prop xt :addr   \ XT to execute on click
    prop obj :ref %object
    template { editable off }

    :: _enter  valof white clr ! ;
    :: _leave  valof cyan clr ! ;

    : trigger-menu-item ( menu-item - )
        xt @ 
        obj @ ?dup if as> then
        ?execute ;

    :: _mousedown ( btn - )
        lmb = -exit 
        me trigger-menu-item ;

class;

0 %menu-item :construct ( - )
    ui-box:construct   valof cyan clr ! ;

\ -- Menu ---------------------------------------------------------------------

c: %menu %panel ;

: *menu ( - menu )
    %menu add { 4 4 at me 50. 8. w 2! } ;

: +menu-item ( object|0 xt text len - menu-item )
    9. h +!        \ grow menu height 
    %menu-item add { 
        me text! xt ! obj ! +bolted 
        w @ 8. + you >w @ max you >w ! \ expand width to fit
    me } 
    0 9 +at ;

\ -- Global Context Menu State ------------------------------------------------

0 value context-menu   \ current open context menu, or 0

: close-context-menu ( - )
    context-menu ?dup if unload then
    0 to context-menu ;

: open-context-menu ( element - )
    close-context-menu
    dup mouse from-root
    *menu to context-menu
    context-menu swap _context-menu
    context-menu #children 0= if close-context-menu then ;

%menu-item :: _mousedown ( btn - )
    menu-item:_mousedown  close-context-menu  
    0 to hovered ;

\ -- Mouse ---------------------------------------------------------------------

variable drag-btn
variable dragging

|| : in?  2>p 2dup me click-box@ overlap? ;

defer _topmost-element
[: 
    [: { 
        mouse in? if drop me then
        me _topmost-element 
    } ;] swap each
;] is _topmost-element

: topmost-element ( - element|0 )
    0 me _topmost-element ;

: hover ( element - )
    dup hovered = if drop exit then
    hovered ?dup if _leave then
    to hovered
    hovered ?dup if _enter then ;

: begin-drag ( btn -- )
    drag-btn ! dragging on ;

: end-drag ( -- )
    dragging off ;

: handle-lmb
    <space> held? ?exit
    lmb pressed? if
        hovered if
            lmb hovered _mousedown
        then
        hovered if 
            lmb hovered _mousedown
            hovered { bolted? } not if
                hovered ctrl? if +select else select then
                selection #items if
                    lmb begin-drag
                then
            then
        else
            selection vacate
        then
    then
    \ lmb letgo? if
    \     hovered if
    \         lmb hovered _mouseup
    \     then
    \ then ;
    drag-btn @ letgo? if
        end-drag
    then ;

: handle-context-menu
    rmb pressed? 
    shift? not and if
        hovered if
            hovered open-context-menu
        else
            close-context-menu
        then
    then
    \ close on LMB click outside menu
    lmb pressed? 
    <space> pressed? not and if
        context-menu if
            hovered context-menu <>
            hovered context-menu contains? not and
            if close-context-menu then
        then
    then ;

: do-drag 
    dragging @ -exit
    mickey 2>p                          \ get mouse delta
    [: { 2dup x 2+! } ;] selection each \ apply to all selected
    2drop ;

: handle-keys
    <del> pressed? if 
        ['] unload selection each
        selection vacate
    then ;

: gui-input ( element - )
    as> 
    topmost-element hover 
    handle-lmb
    handle-context-menu
    do-drag
    handle-keys
;

: click-box  me click-box@ 2over atp 2swap 2- rect ;

: gui-overlay ( - )
    [: { light-green 0.5 ppena! click-box } ;] selection each 
    hovered ?dup if { yellow click-box } then ;

\ -- Inspection ----------------------------------------------------------------

require %idir%/inspect.vfx

%desktop :: _process
    desktop:_process
    rmb pressed? if
        shift? if
            hovered ?dup if toggle-inspector then
        then
        alt? if
            hovered ?dup if unload then
        then
    then ;

\ -- Default context menu ------------------------------------------------------

: +detach-option
    you { bolted? } ?exit
    you [: 
        abspos me dup >root push x 2! 
    ;] s" Detach" +menu-item { } ;

: +attach-option
    you [: 
        selection #items -exit 
        selection peek dup me push 
        5. 5. rot >x 2! 
    ;] 
    s" Attach" +menu-item { } ;

: +delete-option
    you { bolted? } ?exit     
    you [: me unload ;] s" Delete" +menu-item { } ;

: +clone-option
    you { bolted? } ?exit 
    you [: 
        me deep-clone dup me insert-over 
        { 
            5. 5. x 2+! 
            selection vacate
            me selection push
            me to hovered
        } 
    ;] 
    s" Clone" +menu-item { } ;

: +front-option
    you { bolted? } ?exit 
    you [:
        me dup >parent @ push
    ;]
    s" Front" +menu-item { } ;

: +back-option
    you { bolted? } ?exit 
    you [:
        me dup >parent @ unshift
    ;]
    s" Back" +menu-item { } ;

: +common-options
    +clone-option
    +attach-option
    +detach-option
    +front-option
    +back-option
    +delete-option ;

%element :: _context-menu ( menu - )
    as> +common-options ;


%menu-item :: _context-menu ( menu - ) drop ;
%menu :: _context-menu ( menu - ) drop ;