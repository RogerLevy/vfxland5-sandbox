\ =============================================================================
\ GUI
\ =============================================================================

\ -- Dependencies --------------------------------------------------------------

REQUIRE %vfxland5%/forge/lib/dltree.vfx
REQUIRE %vfxland5%/lib/mouse.vfx
REQUIRE %idir%/shapes.vfx
REQUIRE %idir%/colors.vfx

0 value hovered
1024 %addr stack selection

\ -- Context -------------------------------------------------------------------

ECONTEXT gui-ec

\ -- Base Trait ----------------------------------------------------------------

trait: %_element   
    is-a %dltree
    is-a %drawable
    is-a %unloadable
    prop x :fixed
    prop y :fixed
    prop flags
    :: click-box@ ( - x1. y1. x2. y2. ) $DEADBEEF dup dup dup ;
    \ :: _click ( n - ) drop ;
    :: _enter ( - ) ;
    :: _leave ( - ) ;
    :: _mousedown ( btn - ) drop ;  \ lbm , rmb , or mmb
    \ :: _mouseup ( btn - ) drop ;
    \ :: _mousemove ( - ) ;
    :: _process ( - ) ;
    :: _draw ( - ) ;
    :: delete ( - ) stub ;
    :: draggable? ( - flag ) true ;
trait;

\ -- Helpers -------------------------------------------------------------------

: +unloaded  1 flags or! ;
: unloaded?  flags @ 1 and 0<> ;
: +bolted    2 flags or! ;
: bolted?    flags @ 2 and 0<> ;

: abspos  x 2@ me begin >parent @ ?dup while { x 2@ 2+ me } repeat ;
: at-me  abspos atp ;
: box  2over 2+ ;
: ?push  2dup contains? if 2drop exit then push ;
: see-thru   0.25 ppena! ;
\ : click-dims  me click-box@ 2swap 2- ;

\ -- Element Class -------------------------------------------------------------

class: %element
    is-a %_element
    template { gui-ec ecp! in-heap }
class;

0 %element :construct ( - )
    at@p x 2!  gui-ec ecp! in-heap ;

: delete-element ( element - )
    dup hovered = if 0 to hovered then 
    dup dlremove dup free drop ;

%element :: delete
    me delete-element
    me selection contains? if me selection remove then ;

\ -- Element Methods -----------------------------------------------------------

%element :: unload ( - )
    +unloaded ;

defer _sweep
: sweep ( iterable - )
    [: dup _sweep { unloaded? if me delete then } ;] swap each ;
['] sweep is _sweep

%element :: vacate
    ['] unload me each  me sweep ;

%element :: push
    dup %element is? not abort" ELEMENT:PUSH : Source is not an element."
    dltree:push ;

%element :: insert-under
    dup %element is? not abort" ELEMENT:INSERT-UNDER : Source is not an element."
    dltree:insert-under ;

%element :: insert-over
    dup %element is? not abort" ELEMENT:INSERT-OVER : Source is not an element."
    dltree:insert-over ;

%element :: unshift
    dup %element is? not abort" ELEMENT:UNSHIFT : Source is not an element."
    dltree:unshift ;

defer __process
: process ( element - )
    dup _process ['] __process swap each ;
['] process is __process

%element :: draw
    at-me  me _draw ['] draw me each ;

\ -- Desktop -------------------------------------------------------------------

class: %desktop
    %element derive

    :: click-box@ 0 0 winw winh 2>p ;
    :: _process <space> held? lmb? and if mickey 2>p x 2+! then ;
    :: _draw 0 0 at dark-grey winw winh 2>p rectf ;
class;

\ -- UI Box --------------------------------------------------------------------

class: %ui-box
    %element derive

    prop w :fixed
    prop h :fixed
    template { 100. 100. w 2! } 

    EC_MAX_SIZE nprop ec  template { ec clear-ec }

    :: click-box@ ( - x1 y1 x2 y2 )
        abspos w 2@ box ;
class;

0 %ui-box :construct ( - )
    at@p x 2!   ec ecp! in-heap ;

\ -- Selection -----------------------------------------------------------------

: +select  ( element - ) selection ?push ;
: select   ( element - ) selection vacate selection push ;

\ -- Mouse ---------------------------------------------------------------------

variable drag-btn
variable dragging

: pen-in?  me click-box@ at@p 2dup overlap? ;

defer _topmost-element
[: 
    [: { 
        <at pen-in? if drop me then  
        me _topmost-element 
    } ;] swap each
;] is _topmost-element

: topmost-element ( - element|0 )
    0 me _topmost-element ;

: hover ( element - )
    dup hovered = if drop exit then
    hovered ?dup if _leave then
    to hovered
    hovered ?dup if _enter then ;

: begin-drag ( btn -- )
    drag-btn ! dragging on ;

: end-drag ( -- )
    dragging off ;

: handle-lmb
    <space> held? ?exit
    lmb pressed? if
        hovered if 
            lmb hovered _mousedown
            hovered { bolted? } not if
                hovered ctrl? if +select else select then
                selection #items if
                    lmb begin-drag
                then
            then
        else
            selection vacate
        then
    then
    \ lmb letgo? if
    \     hovered if
    \         lmb hovered _mouseup
    \     then
    \ then

    drag-btn @ letgo? if
        end-drag
    then ;

: do-drag 
    dragging @ -exit
    mickey 2>p                          \ get mouse delta
    [: { 2dup x 2+! } ;] selection each \ apply to all selected
    2drop ;

: handle-keys
    <del> pressed? if 
        ['] delete-element selection each
        selection vacate

    then ;

: gui-input ( element - )
    as> 
    mouse at 
    topmost-element hover 
    handle-lmb
    do-drag
    handle-keys
;

: click-box  me click-box@ 2over atp 2swap 2- rect ;

: gui-overlay ( - )
    hovered ?dup if { yellow click-box } then 
    [: { green click-box } ;] selection each ;

\ -- Panel ---------------------------------------------------------------------

class: %panel
    %ui-box derive
    prop clr
    template { black see-thru rgba8@ clr ! }
    :: _draw  clr @ rgba8 w 2@ rectf ;
class;

\ -- Textual Trait -------------------------------------------------------------

redef : *lstring ( a n - a' )
    dup cell+ allocate throw >r r@ lplace r> ;

trait: %textual
    prop txt :addr  \ lstring
    prop fnt :addr 
    prop w :fixed
    prop h :fixed
    prop tx :fixed  \ text offset
    prop ty :fixed

    : _update-box  
        fnt @ fnt!  txt @ lcount textbox 2>p w 2! 2>p tx 2! ;

    :: text! ( a n - ) 
        dup 0< if 2drop exit then
        txt @ >r 
        0 txt !
        *lstring txt !
        _update-box 
        r> free drop \ ignore ior 
    ;

    :: add-char ( n - )
        txt @ lcount cell+ -4 u+ 1 + resize throw txt !
        ( n ) pad c!  pad 1 txt @ lappend 
        _update-box ;

    :: text@ ( - a len | 0 0 )
        txt @ dup if lcount else 0 then ;
trait;

\ -- Label ---------------------------------------------------------------------

variable editing
0 value focus
|| 0 value original

class: %label
    %ui-box derive
    is-a %textual
    prop clr
    prop editable
    prop clear-on-edit
    template { fnt@ fnt ! $FFFFFFFF clr ! editable on }

    \ prop cur

    : editing-me?  editing @   focus me = and ;

    :: _draw  
        editing-me? if red else clr @ rgba8 then
        txt @ ?dup -exit lcount print ;

    :: _mousedown ( btn - )
        lmb = -exit
        editable @ -exit
        me to focus
        editing on 
        original free drop
        txt @ lcount *lstring to original 
        clear-on-edit @ if
            s" " me text! 
        then 
    ;

    : _revert
        original lcount me text!
        original free drop ;

    :: _process
        \ TODO: use ACT> (factor out a %statemachine trait)
        esc-quits on
        editing-me? -exit
        <esc> pressed? if   \ doesn't work if put in the event handler
            editing off
            _revert
            esc-quits off
            exit
        then
        event? -exit
        ALLEGRO_EVENT_KEY_CHAR happened? if 
            the-key <enter> = if
                editing off
                me text@ nip 0= if _revert then
                exit
            then
            \ the-key <enter> = if
            \     10 me add-char
            \     exit
            \ then
            the-key <bksp> = if
                txt @ lcount 1 - 0 max me text!
                exit
            then
            txt @ if
                the-char me add-char
            then
        then ;

class;

: *label ( a len - label )
    %label add { me text! me } ;

trait: %syncable-value
    prop ra :addr \ remote address
    prop val
    prop val-type :addr
    prop was-editing

    :: sync ( - )
        ra @ -exit
        editing-me? not was-editing @ and if
            val @ ra @ !
        then
        editing-me? not if
            ra @ @ val !
        then
        editing-me? was-editing ! ;

trait;


class: %number
    %label derive
    is-a %syncable-value
    template { %int val-type !   clear-on-edit on }

    : val>str ( - a len )
        val-type @ %int = if val @ f" %n" exit then
        val-type @ %fixed = if val @ f" %p" exit then
        -1 abort" invalid val-type" ;

    :: _draw 
        editing-me? not if val>str me text! then
        label:_draw ;

    :: _process
        editing-me?
        label:_process 
        txt @ 0<> and if 
            me text@ s" -" s= not if
                sp@ >r val @
                me text@ ['] evaluate catch if 
                    2drop 
                else 
                    val-type @ %fixed = if
                        me text@ s" ." strin? not if >p then
                    then
                then
                val !
                r> sp! 
            then
        then
        me sync ;

class;

: *int  %number add { val ! %int val-type ! me } ;
: *fixed  %number add { val ! %fixed val-type ! me } ;