\ =============================================================================
\ GUI
\ =============================================================================

\ -- Dependencies --------------------------------------------------------------

REQUIRE %vfxland5%/forge/lib/dltree.vfx
REQUIRE %vfxland5%/lib/mouse.vfx
REQUIRE %idir%/shapes.vfx
REQUIRE %idir%/colors.vfx
REQUIRE %idir%/element.vfx
REQUIRE %idir%/save.vfx

: white-connector ( element - )
    abspos atp 1.0 thick $ffffff44 rgba8
    { abspos } ->line ;

\ -- Mode Toggle (F12) ---------------------------------------------------------

variable using-mode   \ false = designing (default), true = using

: designing? ( - flag ) using-mode @ not ;
: using? ( - flag ) using-mode @ ;

: toggle-mode ( - ) 
    using-mode @ not using-mode ! 
    using? if ." === USE MODE ===" cr 
    else ." === DESIGN MODE ===" cr then  ;

\ -- Cursors -------------------------------------------------------------------

BITMAP %idir%/cursors.png
cursors.png 32 32 TILESET-FROM cursors.ts
\ variable use-cursor
\ variable design-cursor   
0 constant pointer
1 constant hammer  \ hammer design-cursor !
2 constant hand

: default-cursor-bmp ( - bmp )
    cursors.ts using? if pointer else hammer then tile ;

%element :: cursor-bmp ( - bmp )
    default-cursor-bmp ;

: draw-cursor  
    mouse at 
    <space> held? if
        cursors.ts hand tile
    else
        hovered 0<> 
        using? and
        if hovered cursor-bmp else default-cursor-bmp then 
    then
    cput ;

\ -- Desktop -------------------------------------------------------------------

class: %desktop
    %element derive
    prop clr <save
    template { valof dark-grey clr ! +bolted }

    :: click-box@ 0 0 winw winh 2>p ;
    :: _process 
        <space> held? if
            lmb? if pmickey x 2+! then 
        then ;
    :: _draw 0 0 at clr @ rgba8 winw winh 2>p rectf ;
class;

\ -- UI Box --------------------------------------------------------------------

class: %ui-box
    %element derive

    prop w :fixed <save
    prop h :fixed <save

    template { 100. 100. w 2! } 

    EC_MAX_SIZE nprop ec  template { ec clear-ec }

    :: click-box@ ( - x1. y1. x2. y2. ) abspos w 2@ box ;

class;

0 %ui-box :construct ( - )
    at@p x 2!   ec ecp! in-heap ;

\ -- Selection -----------------------------------------------------------------

: +select  ( element - ) selection ?push ;
: select   ( element - ) selection vacate selection push ;

\ -- Panel ---------------------------------------------------------------------

class: %panel
    %ui-box derive
    prop clr <save
    template { black see-thru rgba8@ clr ! }
    :: handy? true ;
    :: _draw  clr @ rgba8 w 2@ rectf ;

    : zoom*  zoom @ dup 2* ;

    :: draw
        clipped? if
            0 0 0 0 sp@ 3 cells + dup cell- dup cell- dup cell- al_get_clipping_rectangle
            me click-box@ 2>i zoom* 2swap 2>i zoom* 2swap    2over 2- al_set_clipping_rectangle
            2>r 2>r
            element:draw
            2r> 2r>
            al_set_clipping_rectangle
        else
            element:draw
        then ;
class;

\ -- Textual Trait -------------------------------------------------------------

trait: %textual
    prop txt :lstring <save  \ heap-allocated lstring
    prop fnt :addr 
    prop w :fixed
    prop h :fixed
    prop tx :fixed  \ text offset
    prop ty :fixed

    : _update-box  
        fnt @ fnt!  txt @ lcount textbox 2>p w 2! 2>p tx 2! ;

    :: text! ( a n - ) 
        dup 0< if 2drop exit then
        txt @ >r 
        *lstring txt !
        _update-box 
        r> free drop \ ignore ior 
    ;

    :: add-char ( n - )
        txt @ lcount cell+ -4 u+ 1 + resize throw txt !
        ( n ) pad c!  pad 1 txt @ lappend 
        _update-box ;

    :: text@ ( - a len|0 )
        txt @ 0= if s" " me text! then
        txt @ lcount ;
trait;

\ -- Label ---------------------------------------------------------------------

variable editing
|| 0 value original

class: %label
    %ui-box derive
    is-a %textual
    prop clr <save
    prop editable <save
    prop clear-on-edit <save
    template { fnt@ fnt ! $FFFFFFFF clr ! editable on }

    :: on-clone
        me text@ *lstring txt ! _update-box ;

    : editing-me?  editing @ focused me = and ;

    : _draw-text
        txt @ ?dup if fnt @ fnt! lcount print then
        editing-me? if
            me text@ nip 8 * 0 +at '_' glyph
        then ;

    :: _draw
        editing-me? if red else clr @ rgba8 then
        _draw-text ;

    :: _mousedown ( btn - )
        lmb = -exit
        editable @ -exit
        me focus
        editing on
        original free drop
        me text@ *lstring to original
        clear-on-edit @ if
            s" " me text!
        then
    ;

    : _revert
        original lcount me text!
        original free drop
        0 to original ;

    : _stop-editing
        editing off
        esc-quits off ;

    :: _process
        repl-game-active @ not if esc-quits on then
        editing-me? -exit
        <esc> pressed? if
            _stop-editing
            _revert
        then ;

    :: _keychar ( key - )
        editing-me? not if drop exit then
        dup <enter> = if
            drop _stop-editing
            exit
        then
        dup <bksp> = if
            drop txt @ lcount 1 - 0 max me text!
            exit
        then
        drop the-char me add-char ;

class;

: *label ( a len - label )
    %label  *add { me text! you { rgba8@ } clr ! me } ;

%label :: click-box@ ( - x1 y1 x2 y2 )
    abspos w @ 16. max h @ box ;

trait: %syncable-value
    prop ra :addr <readonly \ remote address
    prop val <save
    prop val-type <save
    prop was-editing <readonly

    :: sync ( - )
        ra @ -exit
        editing-me? not was-editing @ and if
            val @ ra @ !
        then
        editing-me? not if
            ra @ @ val !
        then
        editing-me? was-editing ! ;

trait;

\ -- Number ---------------------------------------------------------------------

class: %numberfield
    %label derive
    is-a %syncable-value
    template { TYPE_INT val-type !   clear-on-edit on }

    : val>str ( - a len )
        val-type @ TYPE_INT = if val @ f" %n" exit then
        val-type @ TYPE_FIXED = if val @ f" %p" exit then
        -1 abort" invalid val-type" ;

    :: _draw 
        editing-me? not if val>str me text! then
        label:_draw ;

    :: _process
        editing-me?
        label:_process 
        txt @ 0<> and if 
            me text@ s" -" s= not if
                sp@ >r val @
                me text@ ['] evaluate catch if 
                    2drop 
                else 
                    val-type @ TYPE_FIXED = if
                        me text@ s" ." strin? not if >p then
                    then
                then
                val !
                r> sp! 
            then
        then
        me sync ;

class;

: *int  %numberfield  *add { val ! TYPE_INT val-type ! me } ;
: *fixed  %numberfield  *add { val ! TYPE_FIXED val-type ! me } ;

\ -- String Field --------------------------------------------------------------

trait: %syncable-string
    prop ra :addr <readonly
    prop str-type <readonly       \ TYPE_CSTRING or TYPE_LSTRING
    prop was-editing <readonly

    :: sync ( - )
        ra @ -exit
        editing-me? not was-editing @ and if
            str-type @ TYPE_CSTRING = if
                me text@ ra @ place
            else
                ra @ @ free drop
                me text@ *lstring ra @ !
            then
        then
        editing-me? not if
            str-type @ TYPE_CSTRING = if
                ra @ count me text!
            else
                ra @ @ ?dup if lcount else s" " then me text!
            then
        then
        editing-me? was-editing ! ;
trait;

class: %stringfield
    %label derive
    is-a %syncable-string
    template { clear-on-edit off }

    :: _draw
        editing-me? not if me sync then
        label:_draw ;

    :: _process
        label:_process
        me sync ;
class;

: *stringfield ( str-type - stringfield )
    %stringfield  *add { str-type ! s" " me text! me } ;

\ -- Forth elements -----------------------------------------------------------

class: %command
    %label derive
    prop obj :ref %object

    || 2. constant m

    :: click-box@ ( - x1 y1 x2 y2 )
        abspos m m 2- w 2@ m m 2 2 2* 2+ box ;

    :: _draw
        m >i negate dup +at
        white w 2@ m m 2 2 2* 2+ rectf 
        black w 2@ m m 2 2 2* 2+ rect 
        m m 2>i +at
        black _draw-text ;

    :: click ( btn - )
        lmb = -exit
        bolted? not shift? not and ?exit
        obj @ ?dup if as> then
        me text@ evaluate ;

    :: _mousedown ( btn - ) drop ;
class;

: *command ( a len - command )
    %command  *add { me text! me } ;

class: %repl
    %label derive
    prop obj :ref %object

    template { 150. 10. w 2! }

    || redef 2. constant rm

    :: click-box@ ( - x1 y1 x2 y2 )
        abspos m m 2- w 2@ m m 2 2 2* 2+ box ;

    :: _draw
        m >i negate dup +at
        black see-thru w 2@ m m 2 2 2* 2+ rectf
        grey w 2@ m m 2 2 2* 2+ rect
        m m 2>i +at
        yellow _draw-text ;

    : _evaluate
        obj @ ?dup if
            { me text@ evaluate }
        else
            me text@ evaluate
        then ;

    :: _keychar ( key - )
        editing-me? not if drop exit then
        dup <enter> = if
            drop _stop-editing ['] _evaluate catch .throw
            s" " me text! 
            exit
        then
        dup <bksp> = if
            drop txt @ lcount 1 - 0 max me text!
            exit
        then
        drop the-char me add-char ;

    :: text! ( a len - )
        w 2@ 2>r
        textual:text!
        2r> w 2! ;
class;

: *repl ( w - repl )
    %repl  *add { >p w ! s" " me text! me } ;

class: %doer
    %element derive
    prop txt :lstring <save
    :: _draw  designing? -exit white 8. circf ;
    :: click-box@  abspos 8. 8. 2- 16. 16. box ;
    || redef : _evaluate  txt @ ?dup -exit lcount evaluate ;
    :: _process  ['] _evaluate catch .throw ;
class;

\ -- Menu Item ----------------------------------------------------------------

class: %menu-item
    %label derive
    prop xt :addr <readonly  \ XT to execute on click
    prop obj :ref %object <readonly
    prop _clr <readonly
    template { editable off }

    :: _enter  clr @ _clr ! valof white clr ! ;
    :: _leave  _clr @ clr ! ;

    : trigger-menu-item ( menu-item - )
        xt @ 
        obj @ ?dup if as> then
        ?execute ;

    :: _mousedown ( btn - )
        lmb = -exit 
        me trigger-menu-item ;

class;

0 %menu-item :construct ( - )
    ui-box:construct   valof cyan clr ! ;

\ -- Menu ---------------------------------------------------------------------

c: %menu %panel ;

: *menu ( - menu )
    %menu  *add { 4 4 at me 50. 8. w 2! } ;

: *menu-item ( object|0 xt text len - menu-item )
    9. h +!        \ grow menu height 
    %menu-item  *add { 
        me text! xt ! obj ! +bolted 
        w @ 8. + you >w @ max you >w ! \ expand width to fit
    me } 
    0 9 +at ;

: option ( object|0 xt text len - )
    *menu-item { designing? if valof light-red clr ! then } ;

\ -- HUD -----------------------------------------------------------------------

class: %hud
    %element derive
    :: forth@  s" me to hud" ;
class;

0 0 at %hud dmake value hud

: draw-hud
    hud -exit
    0 0 at 
    hud draw ;

\ -- Global Context Menu State ------------------------------------------------

0 value context-menu   \ current open context menu, or 0

: close-context-menu ( - )
    context-menu ?dup if unload then
    0 to context-menu ;

: corral
    \ Clamp element to screen bounds, result in relative coordinates
    abspos                                      ( get absolute position )
    0. 0. 2max                                  ( clamp min to 0,0 )
    winw zoom @ / winh zoom @ / 2>p w 2@ 2-    ( calculate max bounds )
    2min                                        ( clamp to max )
    parent @ if
        parent @ { abspos } 2-                  ( convert to relative )
    then
    x 2! ;

: open-context-menu ( element - )
    close-context-menu
    hud {
        mouse 2>p atp
        *menu to context-menu
        context-menu swap _context-menu
        context-menu #children 0= if close-context-menu exit then
        context-menu ?dup if { corral } then
    } ;

%menu-item :: _mousedown ( btn - )
    menu-item:_mousedown  close-context-menu  
    0 to hovered ;

\ -- Mouse ---------------------------------------------------------------------

variable drag-btn
variable dragging
variable drag-moved  \ true if mouse actually moved during drag

: in-me?  2>p 2dup me click-box@ overlap? ;

: clipped-ancestor? ( element - flag )
    \ Check if mouse is outside any clipped ancestor's bounds
    begin
        >parent @ dup while
        dup { clipped? } if
            >r
            pmouse 2dup r@ click-box@ overlap? not if r> drop true exit then
            r>
        then
    repeat ;

defer _topmost-element
[:
    dup active? not if drop exit then
    [: {
        me active? mouse in-me? and if
            \ Check if mouse is within all clipped ancestors
            me clipped-ancestor? not if drop me then
        then
        me opened? if
            me _topmost-element
        then
    } ;] swap each
;] is _topmost-element

: topmost-element ( - element|0 )
    0 me _topmost-element ;

\ Same as topmost-element but skips root and desktops (for cycling)
|| 0 value top-selectable

defer _topmost-selectable
[:
    dup active? not if drop exit then
    [: {
        me active? mouse in-me? and parent @ and me %desktop is? not and if
            me clipped-ancestor? not if
                me to top-selectable
            then
        then
        me opened? if me _topmost-selectable then
    } ;] swap each
;] is _topmost-selectable

: topmost-selectable ( - element|0 )
    0 to top-selectable
    me _topmost-selectable
    top-selectable ;

\ Find element below 'skip' under mouse (for cycling selection)
\ "Below" = earlier in traversal (visually underneath)
\ Returns 0 if skip not found or nothing below it
|| 0 value skip-element
|| 0 value found-skip
|| 0 value below-element

defer _element-below
[:  ( element - )
    dup active? not if drop exit then
    [: {
        me active? mouse in-me? and parent @ and me %desktop is? not and if
            me clipped-ancestor? not if
                me skip-element = if
                    true to found-skip
                else
                    found-skip not if me to below-element then
                then
            then
        then
        me opened? if me _element-below then
    } ;] swap each
;] is _element-below

: element-below ( skip-elem root - elem|0 )
    swap to skip-element
    false to found-skip
    0 to below-element
    _element-below
    below-element ;

: hover ( element - )
    dup hovered = if drop exit then
    hovered ?dup if _leave then
    to hovered
    hovered ?dup if _enter then ;

: target-element ( - element|0 )
    \ Returns selected element if under mouse, otherwise hovered element
    selection #items if
        mouse this { in-me? } if this exit then
    then
    hovered ;

|| 0 value click-candidate  \ element that might receive a cycle-click
|| 0 value last-click-x
|| 0 value last-click-y

: mouse-moved-since-click? ( - flag )
    mouse last-click-y <> swap last-click-x <> or ;

: record-click-position ( - )
    mouse to last-click-y to last-click-x ;

: preview-selection ( - element|0 )
    \ In designing mode, preview what would be selected on click
    designing? not if hovered exit then
    \ If mouse moved, would select topmost
    mouse-moved-since-click? if hovered exit then
    selection #items 0= if hovered exit then
    \ If selected element is under mouse and mouse hasn't moved, show cycle target
    mouse this { in-me? } if
        this me element-below ?dup ?exit
        topmost-selectable exit
    then
    hovered ;

: begin-drag ( btn -- )
    drag-btn ! dragging on drag-moved off ;

: end-drag ( -- )
    dragging off drag-moved off ;

: handle-rmb
    rmb pressed? if
        target-element ?dup if
            dup handy? if drop else rmb swap _mousedown then
        then
    then ;

: cycle-select ( - )
    \ Cycle to element below the current selection
    selection #items 0= if exit then
    this me element-below ?dup if
        select
    else
        topmost-selectable ?dup if select then
    then ;

: try-cycle-select ( - flag )
    \ Returns true if cycling was set up, false otherwise
    mouse-moved-since-click? if false exit then
    selection #items 0= if false exit then
    mouse this { in-me? } not if false exit then
    \ Selected element is under mouse and mouse hasn't moved - set up cycling
    this to click-candidate
    true ;

defer cloned ( element - ) ['] drop is cloned

: handle-lmb
    <space> held? ?exit
    lmb pressed? if
        0 to click-candidate
        hovered if
            \ Clone if holding <CTRL>
            ctrl? if 
                hovered deep-clone dup hovered insert-over 
                to hovered
                hovered { -bolted }
                hovered cloned
            then

            \ Handy elements: always draggable regardless of mode (unless bolted)
            hovered handy? hovered { bolted? } not and if
                try-cycle-select if
                    lmb begin-drag
                else
                    \ hovered ctrl? if +select else select then
                    hovered select
                    lmb begin-drag
                then
                record-click-position
                exit
            then
            \ Bolted elements always "use" on click
            \ In using mode, all elements "use" on click
            hovered { bolted? } using? or if
                lmb hovered _mousedown
                lmb drag-btn ! drag-moved off  \ track for click detection, but don't enable dragging
                record-click-position
            else
                \ Designing mode + not bolted = drag behavior
                lmb hovered _mousedown
                hovered -exit
                try-cycle-select if
                    this { bolted? } not if lmb begin-drag then
                else
                    \ hovered ctrl? if +select else select then
                    hovered select
                    selection #items if lmb begin-drag then
                then
                record-click-position
            then
        else
            selection vacate
        then
    then
    drag-btn @ letgo? if
        \ Call click on release without movement (using mode or bolted elements)
        using? hovered ?dup if { bolted? } else false then or
        drag-moved @ not and if
            hovered ?dup if 
                lmb swap click 
                \ exit
            then
        then
        \ If released without actual movement and had a cycle candidate, cycle
        drag-moved @ not click-candidate and if
            cycle-select
        then
        end-drag
        0 to click-candidate
    then ;

: handle-context-menu
    \ Allow context menu in designing mode, or for handy elements in any mode
    designing? not if
        target-element dup 0= if drop exit then
        handy? not ?exit
    then
    rmb pressed? shift? not and if
        target-element ?dup if
            open-context-menu
        else
            close-context-menu
        then
    then
    \ close on LMB click outside menu
    lmb pressed? <space> pressed? not and if
        context-menu if
            hovered context-menu <>
            hovered context-menu contains? not and
            if close-context-menu then
        then
    then ;

: do-drag
    dragging @ -exit
    pmickey                             \ get mouse delta
    2dup or if drag-moved on then       \ track if any movement
    [: { 2dup x 2+! } ;] selection each \ apply to all selected
    2drop ;

: handle-keys
    <del> pressed? if
        ['] unload selection each
        selection vacate
    then ;

: handle-mode-toggle
    <tab> pressed? if toggle-mode then ;

: handle-focused-keys
    focused -exit
    ALLEGRO_EVENT_KEY_DOWN happened? if
        the-key focused _keydown
    then
    ALLEGRO_EVENT_KEY_CHAR happened? if
        the-key focused _keychar
    then ;

: handle-focused-mouse-wheel
    focused -exit
    ALLEGRO_EVENT_MOUSE_AXES happened? if
        the-wheel focused _mousewheel
    then ; 

: gui-input ( element - )
    as>
    topmost-element hover  \ Update hover FIRST so hovered is current
    handle-lmb
    handle-rmb
    do-drag
    handle-context-menu
    handle-mode-toggle
    begin event? while
        handle-focused-keys
        handle-focused-mouse-wheel
    repeat
    handle-keys
;

: process-gui ( element - )
    dup gui-input dup process sweep ;

: click-box  -1. thick me click-box@ 2over atp 2swap 2- rect ;

: click-fbox  
    me %desktop is? ?exit
    designing?   me handy? or if
        get-blender additive-mode
        0.2 ppena! me click-box@ 2over atp 2swap 2- rectf 
        set-blender 
    then
    1.0 ppena! click-box ;

: gui-overlay ( element - )
    as>
    [: { light-green click-fbox } ;] selection each
    designing? if
        \ In designing mode, preview what would be selected on click
        preview-selection ?dup if { bolted? if yellow else green then click-fbox } then
    else
        \ In using mode, show hover
        \ hovered ?dup if { bolted? if yellow else green then click-fbox } then
        hovered ?dup if { bolted? not if green click-box then } then
    then
    focused ?dup if { cyan click-box } then ;

\ -- Inspection ----------------------------------------------------------------

require %idir%/inspect.vfx

%desktop :: _process
    desktop:_process
    rmb pressed? if
        shift? if
            target-element ?dup if toggle-inspector then
        then
    then ;

\ -- Desktop-specific HUDs -----------------------------------------------------
    
class: %desktop-hud
    %element derive
    :: active? parent @ ?dup if active? else false then ;
    :: _process
        parent @ ?dup if
            dup >x 2@ 2negate x 2!  \ stay fixed on screen
            me swap push            \ stay on top
        then ;
class;

\ -- Default context menu ------------------------------------------------------

: detach,
    you { bolted? } ?exit
    you [: 
        abspos me dup >root push x 2! 
    ;] s" Detach" option ;

: attach,
    selection #items if
        you >parent @ this = ?exit
    else
        exit
    then
    you [: 
        selection #items -exit 
        this me = ?exit
        this { you relpos x 2! }
        this me push 
    ;] 
    s" Attach" option ;

: delete,
    you { bolted? } ?exit     
    you [: me unload ;] s" Delete" option ;

: clone,
    \ you { bolted? } ?exit 
    you [: 
        me deep-clone dup me insert-over 
        { 
            5. 5. x 2+! 
            selection vacate
            me selection push
            -bolted
            me to hovered
        } 
    ;] 
    s" Clone" option ;

: front,
    you >parent @ -exit
    you { bolted? parent @ >highest @ me = or } ?exit 
    you [:
        me dup >parent @ push
    ;]
    s" Front" option ;

: back,
    you >parent @ -exit
    you { bolted? parent @ >lowest @ me = or } ?exit 
    you [:
        me dup >parent @ unshift
    ;]
    s" Back" option ;

: bolt, 
    you [: 
        bolted? if -bolted else +bolted then
    ;] 
    you { bolted? } if s" Unbolt" else s" Bolt" then option ;

: default-sticky,
    you { bolted? } ?exit
    hud -exit
    you >parent @ hud <> if
    \     you [: abspos me dup >root push x 2! ;] s" Unsticky" option
    \ else
        you [: abspos me hud push x 2! ;] s" Global Sticky" option 
    then ;

defer sticky,  ['] default-sticky, is sticky,

: clear,
    you #children -exit
    you [: ['] unload me each ;] 
    s" Clear" option ;

: save-tree-dialog ( element - )
    0 z" Save JSON" z" *.json" ALLEGRO_FILECHOOSER_SAVE file-dialog
    dup if 
        -ext f" %s.json" save-tree
    else 
        2drop
    then ;

: save,
    you [: me save-tree-dialog ;] s" Save" option ;

|| 0 value capture-target
|| 10000 %addr stack basket

: _gather-captured ( element - )
    [ here ]
    as>
    me active? not ?exit
    me capture-target = ?exit  \ Skip target itself
    me capture-target descendant? ?exit  \ Skip target's ancestors
    me hud descendant? ?exit   \ Skip hud

    \ Check if within bounds and move to target
    bolted? not if
        me click-box@ 1. 1. 2-  capture-target click-box@ 1. 1. 2- overlap? if
            abspos  capture-target { abspos } 2-  ( rx. ry. )
            me basket push
            x 2!
        then
    then

    \ Recurse into children
    ( [ xt ] ) literal me each ;

: capture,
    you [:
        me to capture-target
        ['] _gather-captured  me >parent @ each
        [: capture-target push ;] basket each
        basket vacate
    ;]
    s" Capture" option ;

: release,
    you [:
        [: as>
            bolted? ?exit
            abspos parent @ >parent @ { abspos } 2-
            me parent @ >parent @ push 
            x 2!
        ;] me each
    ;]
    s" Release" option ;

: common-options,
    \ designing? if clone, then
    designing? if attach, then
    designing? if capture, then
    designing? if release, then
    save,
    front,
    back,
    designing? if bolt, then
    designing? if sticky, then
    designing? if clear, then
    delete, ;

%element :: _context-menu ( menu - )
    as> common-options, ;

%menu-item :: _context-menu ( menu - ) drop ;
%menu :: _context-menu ( menu - ) drop ;